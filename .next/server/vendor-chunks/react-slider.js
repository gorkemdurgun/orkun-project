"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-slider";
exports.ids = ["vendor-chunks/react-slider"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-slider/dist/es/dev/components/ReactSlider/ReactSlider.mjs":
/*!**************************************************************************************!*\
  !*** ./node_modules/react-slider/dist/es/dev/components/ReactSlider/ReactSlider.mjs ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ ReactSlider$1)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/extends */ \"(ssr)/./node_modules/@babel/runtime/helpers/extends.js\");\n/* harmony import */ var _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/inheritsLoose */ \"(ssr)/./node_modules/@babel/runtime/helpers/inheritsLoose.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! prop-types */ \"(ssr)/./node_modules/prop-types/index.js\");\n\n\n\n\n\nvar _jsxFileName = \"/Users/krise/github/react-slider/src/components/ReactSlider/ReactSlider.jsx\";\n/**\n * To prevent text selection while dragging.\n * http://stackoverflow.com/questions/5429827/how-can-i-prevent-text-element-selection-with-cursor-drag\n */\n\nfunction pauseEvent(e) {\n  if (e && e.stopPropagation) {\n    e.stopPropagation();\n  }\n\n  if (e && e.preventDefault) {\n    e.preventDefault();\n  }\n\n  return false;\n}\n\nfunction stopPropagation(e) {\n  if (e.stopPropagation) {\n    e.stopPropagation();\n  }\n}\n\nfunction sanitizeInValue(x) {\n  if (x == null) {\n    return [];\n  }\n\n  return Array.isArray(x) ? x.slice() : [x];\n}\n\nfunction prepareOutValue(x) {\n  return x !== null && x.length === 1 ? x[0] : x.slice();\n}\n\nfunction trimSucceeding(length, nextValue, minDistance, max) {\n  for (let i = 0; i < length; i += 1) {\n    const padding = max - i * minDistance;\n\n    if (nextValue[length - 1 - i] > padding) {\n      // eslint-disable-next-line no-param-reassign\n      nextValue[length - 1 - i] = padding;\n    }\n  }\n}\n\nfunction trimPreceding(length, nextValue, minDistance, min) {\n  for (let i = 0; i < length; i += 1) {\n    const padding = min + i * minDistance;\n\n    if (nextValue[i] < padding) {\n      // eslint-disable-next-line no-param-reassign\n      nextValue[i] = padding;\n    }\n  }\n}\n\nfunction addHandlers(eventMap) {\n  Object.keys(eventMap).forEach(key => {\n    if (typeof document !== 'undefined') {\n      document.addEventListener(key, eventMap[key], false);\n    }\n  });\n}\n\nfunction removeHandlers(eventMap) {\n  Object.keys(eventMap).forEach(key => {\n    if (typeof document !== 'undefined') {\n      document.removeEventListener(key, eventMap[key], false);\n    }\n  });\n}\n\nfunction trimAlignValue(val, props) {\n  return alignValue(trimValue(val, props), props);\n}\n\nfunction alignValue(val, props) {\n  const valModStep = (val - props.min) % props.step;\n  let alignedValue = val - valModStep;\n\n  if (Math.abs(valModStep) * 2 >= props.step) {\n    alignedValue += valModStep > 0 ? props.step : -props.step;\n  }\n\n  return parseFloat(alignedValue.toFixed(5));\n}\n\nfunction trimValue(val, props) {\n  let trimmed = val;\n\n  if (trimmed <= props.min) {\n    trimmed = props.min;\n  }\n\n  if (trimmed >= props.max) {\n    trimmed = props.max;\n  }\n\n  return trimmed;\n}\n\nlet ReactSlider = /*#__PURE__*/function (_React$Component) {\n  _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_1__(ReactSlider, _React$Component);\n\n  function ReactSlider(_props) {\n    var _this;\n\n    _this = _React$Component.call(this, _props) || this;\n\n    _this.onKeyUp = () => {\n      _this.onEnd();\n    };\n\n    _this.onMouseUp = () => {\n      _this.onEnd(_this.getMouseEventMap());\n    };\n\n    _this.onTouchEnd = e => {\n      e.preventDefault();\n\n      _this.onEnd(_this.getTouchEventMap());\n    };\n\n    _this.onBlur = () => {\n      _this.setState({\n        index: -1\n      }, _this.onEnd(_this.getKeyDownEventMap()));\n    };\n\n    _this.onMouseMove = e => {\n      // Prevent controlled updates from happening while mouse is moving\n      _this.setState({\n        pending: true\n      });\n\n      const position = _this.getMousePosition(e);\n\n      const diffPosition = _this.getDiffPosition(position[0]);\n\n      const newValue = _this.getValueFromPosition(diffPosition);\n\n      _this.move(newValue);\n    };\n\n    _this.onTouchMove = e => {\n      if (e.touches.length > 1) {\n        return;\n      } // Prevent controlled updates from happending while touch is moving\n\n\n      _this.setState({\n        pending: true\n      });\n\n      const position = _this.getTouchPosition(e);\n\n      if (typeof _this.isScrolling === 'undefined') {\n        const diffMainDir = position[0] - _this.startPosition[0];\n        const diffScrollDir = position[1] - _this.startPosition[1];\n        _this.isScrolling = Math.abs(diffScrollDir) > Math.abs(diffMainDir);\n      }\n\n      if (_this.isScrolling) {\n        _this.setState({\n          index: -1\n        });\n\n        return;\n      }\n\n      const diffPosition = _this.getDiffPosition(position[0]);\n\n      const newValue = _this.getValueFromPosition(diffPosition);\n\n      _this.move(newValue);\n    };\n\n    _this.onKeyDown = e => {\n      if (e.ctrlKey || e.shiftKey || e.altKey || e.metaKey) {\n        return;\n      } // Prevent controlled updates from happening while a key is pressed\n\n\n      _this.setState({\n        pending: true\n      });\n\n      switch (e.key) {\n        case 'ArrowLeft':\n        case 'ArrowDown':\n        case 'Left':\n        case 'Down':\n          e.preventDefault();\n\n          _this.moveDownByStep();\n\n          break;\n\n        case 'ArrowRight':\n        case 'ArrowUp':\n        case 'Right':\n        case 'Up':\n          e.preventDefault();\n\n          _this.moveUpByStep();\n\n          break;\n\n        case 'Home':\n          e.preventDefault();\n\n          _this.move(_this.props.min);\n\n          break;\n\n        case 'End':\n          e.preventDefault();\n\n          _this.move(_this.props.max);\n\n          break;\n\n        case 'PageDown':\n          e.preventDefault();\n\n          _this.moveDownByStep(_this.props.pageFn(_this.props.step));\n\n          break;\n\n        case 'PageUp':\n          e.preventDefault();\n\n          _this.moveUpByStep(_this.props.pageFn(_this.props.step));\n\n          break;\n      }\n    };\n\n    _this.onSliderMouseDown = e => {\n      // do nothing if disabled or right click\n      if (_this.props.disabled || e.button === 2) {\n        return;\n      } // Prevent controlled updates from happening while mouse is moving\n\n\n      _this.setState({\n        pending: true\n      });\n\n      if (!_this.props.snapDragDisabled) {\n        const position = _this.getMousePosition(e);\n\n        _this.forceValueFromPosition(position[0], i => {\n          _this.start(i, position[0]);\n\n          addHandlers(_this.getMouseEventMap());\n        });\n      }\n\n      pauseEvent(e);\n    };\n\n    _this.onSliderClick = e => {\n      if (_this.props.disabled) {\n        return;\n      }\n\n      if (_this.props.onSliderClick && !_this.hasMoved) {\n        const position = _this.getMousePosition(e);\n\n        const valueAtPos = trimAlignValue(_this.calcValue(_this.calcOffsetFromPosition(position[0])), _this.props);\n\n        _this.props.onSliderClick(valueAtPos);\n      }\n    };\n\n    _this.createOnKeyDown = i => e => {\n      if (_this.props.disabled) {\n        return;\n      }\n\n      _this.start(i);\n\n      addHandlers(_this.getKeyDownEventMap());\n      pauseEvent(e);\n    };\n\n    _this.createOnMouseDown = i => e => {\n      // do nothing if disabled or right click\n      if (_this.props.disabled || e.button === 2) {\n        return;\n      } // Prevent controlled updates from happending while mouse is moving\n\n\n      _this.setState({\n        pending: true\n      });\n\n      const position = _this.getMousePosition(e);\n\n      _this.start(i, position[0]);\n\n      addHandlers(_this.getMouseEventMap());\n      pauseEvent(e);\n    };\n\n    _this.createOnTouchStart = i => e => {\n      if (_this.props.disabled || e.touches.length > 1) {\n        return;\n      } // Prevent controlled updates from happending while touch is moving\n\n\n      _this.setState({\n        pending: true\n      });\n\n      const position = _this.getTouchPosition(e);\n\n      _this.startPosition = position; // don't know yet if the user is trying to scroll\n\n      _this.isScrolling = undefined;\n\n      _this.start(i, position[0]);\n\n      addHandlers(_this.getTouchEventMap());\n      stopPropagation(e);\n    };\n\n    _this.handleResize = () => {\n      // setTimeout of 0 gives element enough time to have assumed its new size if\n      // it is being resized\n      const resizeTimeout = window.setTimeout(() => {\n        // drop this timeout from pendingResizeTimeouts to reduce memory usage\n        _this.pendingResizeTimeouts.shift();\n\n        _this.resize();\n      }, 0);\n\n      _this.pendingResizeTimeouts.push(resizeTimeout);\n    };\n\n    _this.renderThumb = (style, i) => {\n      const className = _this.props.thumbClassName + \" \" + _this.props.thumbClassName + \"-\" + i + \" \" + (_this.state.index === i ? _this.props.thumbActiveClassName : '');\n      const props = {\n        'ref': r => {\n          _this[\"thumb\" + i] = r;\n        },\n        'key': _this.props.thumbClassName + \"-\" + i,\n        className,\n        style,\n        'onMouseDown': _this.createOnMouseDown(i),\n        'onTouchStart': _this.createOnTouchStart(i),\n        'onFocus': _this.createOnKeyDown(i),\n        'tabIndex': 0,\n        'role': 'slider',\n        'aria-orientation': _this.props.orientation,\n        'aria-valuenow': _this.state.value[i],\n        'aria-valuemin': _this.props.min,\n        'aria-valuemax': _this.props.max,\n        'aria-label': Array.isArray(_this.props.ariaLabel) ? _this.props.ariaLabel[i] : _this.props.ariaLabel,\n        'aria-labelledby': Array.isArray(_this.props.ariaLabelledby) ? _this.props.ariaLabelledby[i] : _this.props.ariaLabelledby,\n        'aria-disabled': _this.props.disabled\n      };\n      const state = {\n        index: i,\n        value: prepareOutValue(_this.state.value),\n        valueNow: _this.state.value[i]\n      };\n\n      if (_this.props.ariaValuetext) {\n        props['aria-valuetext'] = typeof _this.props.ariaValuetext === 'string' ? _this.props.ariaValuetext : _this.props.ariaValuetext(state);\n      }\n\n      return _this.props.renderThumb(props, state);\n    };\n\n    _this.renderTrack = (i, offsetFrom, offsetTo) => {\n      const props = {\n        key: _this.props.trackClassName + \"-\" + i,\n        className: _this.props.trackClassName + \" \" + _this.props.trackClassName + \"-\" + i,\n        style: _this.buildTrackStyle(offsetFrom, _this.state.upperBound - offsetTo)\n      };\n      const state = {\n        index: i,\n        value: prepareOutValue(_this.state.value)\n      };\n      return _this.props.renderTrack(props, state);\n    };\n\n    let value = sanitizeInValue(_props.value);\n\n    if (!value.length) {\n      value = sanitizeInValue(_props.defaultValue);\n    } // array for storing resize timeouts ids\n\n\n    _this.pendingResizeTimeouts = [];\n    const zIndices = [];\n\n    for (let i = 0; i < value.length; i += 1) {\n      value[i] = trimAlignValue(value[i], _props);\n      zIndices.push(i);\n    }\n\n    _this.resizeObserver = null;\n    _this.resizeElementRef = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_2__.createRef();\n    _this.state = {\n      index: -1,\n      upperBound: 0,\n      sliderLength: 0,\n      value,\n      zIndices\n    };\n    return _this;\n  }\n\n  var _proto = ReactSlider.prototype;\n\n  _proto.componentDidMount = function componentDidMount() {\n    if (typeof window !== 'undefined') {\n      this.resizeObserver = new ResizeObserver(this.handleResize);\n      this.resizeObserver.observe(this.resizeElementRef.current);\n      this.resize();\n    }\n  } // Keep the internal `value` consistent with an outside `value` if present.\n  // This basically allows the slider to be a controlled component.\n  ;\n\n  ReactSlider.getDerivedStateFromProps = function getDerivedStateFromProps(props, state) {\n    const value = sanitizeInValue(props.value);\n\n    if (!value.length) {\n      return null;\n    } // Do not allow controlled upates to happen while we have pending updates\n\n\n    if (state.pending) {\n      return null;\n    }\n\n    return {\n      value: value.map(item => trimAlignValue(item, props))\n    };\n  };\n\n  _proto.componentDidUpdate = function componentDidUpdate() {\n    // If an upperBound has not yet been determined (due to the component being hidden\n    // during the mount event, or during the last resize), then calculate it now\n    if (this.state.upperBound === 0) {\n      this.resize();\n    }\n  };\n\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    this.clearPendingResizeTimeouts();\n\n    if (this.resizeObserver) {\n      this.resizeObserver.disconnect();\n    }\n  };\n\n  _proto.onEnd = function onEnd(eventMap) {\n    if (eventMap) {\n      removeHandlers(eventMap);\n    }\n\n    if (this.hasMoved) {\n      this.fireChangeEvent('onAfterChange');\n    } // Allow controlled updates to continue\n\n\n    this.setState({\n      pending: false\n    });\n    this.hasMoved = false;\n  };\n\n  _proto.getValue = function getValue() {\n    return prepareOutValue(this.state.value);\n  };\n\n  _proto.getClosestIndex = function getClosestIndex(pixelOffset) {\n    let minDist = Number.MAX_VALUE;\n    let closestIndex = -1;\n    const {\n      value\n    } = this.state;\n    const l = value.length;\n\n    for (let i = 0; i < l; i += 1) {\n      const offset = this.calcOffset(value[i]);\n      const dist = Math.abs(pixelOffset - offset);\n\n      if (dist < minDist) {\n        minDist = dist;\n        closestIndex = i;\n      }\n    }\n\n    return closestIndex;\n  };\n\n  _proto.getMousePosition = function getMousePosition(e) {\n    return [e[\"page\" + this.axisKey()], e[\"page\" + this.orthogonalAxisKey()]];\n  };\n\n  _proto.getTouchPosition = function getTouchPosition(e) {\n    const touch = e.touches[0];\n    return [touch[\"page\" + this.axisKey()], touch[\"page\" + this.orthogonalAxisKey()]];\n  };\n\n  _proto.getKeyDownEventMap = function getKeyDownEventMap() {\n    return {\n      keydown: this.onKeyDown,\n      keyup: this.onKeyUp,\n      focusout: this.onBlur\n    };\n  };\n\n  _proto.getMouseEventMap = function getMouseEventMap() {\n    return {\n      mousemove: this.onMouseMove,\n      mouseup: this.onMouseUp\n    };\n  };\n\n  _proto.getTouchEventMap = function getTouchEventMap() {\n    return {\n      touchmove: this.onTouchMove,\n      touchend: this.onTouchEnd\n    };\n  };\n\n  _proto.getValueFromPosition = function getValueFromPosition(position) {\n    const diffValue = position / (this.state.sliderLength - this.state.thumbSize) * (this.props.max - this.props.min);\n    return trimAlignValue(this.state.startValue + diffValue, this.props);\n  };\n\n  _proto.getDiffPosition = function getDiffPosition(position) {\n    let diffPosition = position - this.state.startPosition;\n\n    if (this.props.invert) {\n      diffPosition *= -1;\n    }\n\n    return diffPosition;\n  } // create the `keydown` handler for the i-th thumb\n  ;\n\n  _proto.resize = function resize() {\n    const {\n      slider,\n      thumb0: thumb\n    } = this;\n\n    if (!slider || !thumb) {\n      return;\n    }\n\n    const sizeKey = this.sizeKey(); // For the slider size, we want to use the client width/height, excluding any borders\n\n    const sliderRect = slider.getBoundingClientRect();\n    const sliderSize = slider[sizeKey];\n    const sliderMax = sliderRect[this.posMaxKey()];\n    const sliderMin = sliderRect[this.posMinKey()]; // For the thumb size, we want to use the outer width/height, including any borders\n\n    const thumbRect = thumb.getBoundingClientRect();\n    const thumbSize = thumbRect[sizeKey.replace('client', '').toLowerCase()];\n    const upperBound = sliderSize - thumbSize;\n    const sliderLength = Math.abs(sliderMax - sliderMin);\n\n    if (this.state.upperBound !== upperBound || this.state.sliderLength !== sliderLength || this.state.thumbSize !== thumbSize) {\n      this.setState({\n        upperBound,\n        sliderLength,\n        thumbSize\n      });\n    }\n  } // calculates the offset of a thumb in pixels based on its value.\n  ;\n\n  _proto.calcOffset = function calcOffset(value) {\n    const range = this.props.max - this.props.min;\n\n    if (range === 0) {\n      return 0;\n    }\n\n    const ratio = (value - this.props.min) / range;\n    return ratio * this.state.upperBound;\n  } // calculates the value corresponding to a given pixel offset, i.e. the inverse of `calcOffset`.\n  ;\n\n  _proto.calcValue = function calcValue(offset) {\n    const ratio = offset / this.state.upperBound;\n    return ratio * (this.props.max - this.props.min) + this.props.min;\n  };\n\n  _proto.calcOffsetFromPosition = function calcOffsetFromPosition(position) {\n    const {\n      slider\n    } = this;\n    const sliderRect = slider.getBoundingClientRect();\n    const sliderMax = sliderRect[this.posMaxKey()];\n    const sliderMin = sliderRect[this.posMinKey()]; // The `position` value passed in is the mouse position based on the window height.\n    // The slider bounding rect is based on the viewport, so we must add the window scroll\n    // offset to normalize the values.\n\n    const windowOffset = window[\"page\" + this.axisKey() + \"Offset\"];\n    const sliderStart = windowOffset + (this.props.invert ? sliderMax : sliderMin);\n    let pixelOffset = position - sliderStart;\n\n    if (this.props.invert) {\n      pixelOffset = this.state.sliderLength - pixelOffset;\n    }\n\n    pixelOffset -= this.state.thumbSize / 2;\n    return pixelOffset;\n  } // Snaps the nearest thumb to the value corresponding to `position`\n  // and calls `callback` with that thumb's index.\n  ;\n\n  _proto.forceValueFromPosition = function forceValueFromPosition(position, callback) {\n    const pixelOffset = this.calcOffsetFromPosition(position);\n    const closestIndex = this.getClosestIndex(pixelOffset);\n    const nextValue = trimAlignValue(this.calcValue(pixelOffset), this.props); // Clone this.state.value since we'll modify it temporarily\n    // eslint-disable-next-line zillow/react/no-access-state-in-setstate\n\n    const value = this.state.value.slice();\n    value[closestIndex] = nextValue; // Prevents the slider from shrinking below `props.minDistance`\n\n    for (let i = 0; i < value.length - 1; i += 1) {\n      if (value[i + 1] - value[i] < this.props.minDistance) {\n        return;\n      }\n    }\n\n    this.fireChangeEvent('onBeforeChange');\n    this.hasMoved = true;\n    this.setState({\n      value\n    }, () => {\n      callback(closestIndex);\n      this.fireChangeEvent('onChange');\n    });\n  } // clear all pending timeouts to avoid error messages after unmounting\n  ;\n\n  _proto.clearPendingResizeTimeouts = function clearPendingResizeTimeouts() {\n    do {\n      const nextTimeout = this.pendingResizeTimeouts.shift();\n      clearTimeout(nextTimeout);\n    } while (this.pendingResizeTimeouts.length);\n  };\n\n  _proto.start = function start(i, position) {\n    const thumbRef = this[\"thumb\" + i];\n\n    if (thumbRef) {\n      thumbRef.focus();\n    }\n\n    const {\n      zIndices\n    } = this.state; // remove wherever the element is\n\n    zIndices.splice(zIndices.indexOf(i), 1); // add to end\n\n    zIndices.push(i);\n    this.setState(prevState => ({\n      startValue: prevState.value[i],\n      startPosition: position !== undefined ? position : prevState.startPosition,\n      index: i,\n      zIndices\n    }));\n  };\n\n  _proto.moveUpByStep = function moveUpByStep(step) {\n    if (step === void 0) {\n      step = this.props.step;\n    }\n\n    const oldValue = this.state.value[this.state.index]; // if the slider is inverted and horizontal we want to honor the inverted value\n\n    const newValue = this.props.invert && this.props.orientation === 'horizontal' ? oldValue - step : oldValue + step;\n    const trimAlign = trimAlignValue(newValue, this.props);\n    this.move(Math.min(trimAlign, this.props.max));\n  };\n\n  _proto.moveDownByStep = function moveDownByStep(step) {\n    if (step === void 0) {\n      step = this.props.step;\n    }\n\n    const oldValue = this.state.value[this.state.index]; // if the slider is inverted and horizontal we want to honor the inverted value\n\n    const newValue = this.props.invert && this.props.orientation === 'horizontal' ? oldValue + step : oldValue - step;\n    const trimAlign = trimAlignValue(newValue, this.props);\n    this.move(Math.max(trimAlign, this.props.min));\n  };\n\n  _proto.move = function move(newValue) {\n    // Clone this.state.value since we'll modify it temporarily\n    // eslint-disable-next-line zillow/react/no-access-state-in-setstate\n    const value = this.state.value.slice();\n    const {\n      index\n    } = this.state;\n    const {\n      length\n    } = value; // Short circuit if the value is not changing\n\n    const oldValue = value[index];\n\n    if (newValue === oldValue) {\n      return;\n    } // Trigger only before the first movement\n\n\n    if (!this.hasMoved) {\n      this.fireChangeEvent('onBeforeChange');\n    }\n\n    this.hasMoved = true; // if \"pearling\" (= thumbs pushing each other) is disabled,\n    // prevent the thumb from getting closer than `minDistance` to the previous or next thumb.\n\n    const {\n      pearling,\n      max,\n      min,\n      minDistance\n    } = this.props;\n\n    if (!pearling) {\n      if (index > 0) {\n        const valueBefore = value[index - 1];\n\n        if (newValue < valueBefore + minDistance) {\n          // eslint-disable-next-line no-param-reassign\n          newValue = valueBefore + minDistance;\n        }\n      }\n\n      if (index < length - 1) {\n        const valueAfter = value[index + 1];\n\n        if (newValue > valueAfter - minDistance) {\n          // eslint-disable-next-line no-param-reassign\n          newValue = valueAfter - minDistance;\n        }\n      }\n    }\n\n    value[index] = newValue; // if \"pearling\" is enabled, let the current thumb push the pre- and succeeding thumbs.\n\n    if (pearling && length > 1) {\n      if (newValue > oldValue) {\n        this.pushSucceeding(value, minDistance, index);\n        trimSucceeding(length, value, minDistance, max);\n      } else if (newValue < oldValue) {\n        this.pushPreceding(value, minDistance, index);\n        trimPreceding(length, value, minDistance, min);\n      }\n    } // Normally you would use `shouldComponentUpdate`,\n    // but since the slider is a low-level component,\n    // the extra complexity might be worth the extra performance.\n\n\n    this.setState({\n      value\n    }, this.fireChangeEvent.bind(this, 'onChange'));\n  };\n\n  _proto.pushSucceeding = function pushSucceeding(value, minDistance, index) {\n    let i;\n    let padding;\n\n    for (i = index, padding = value[i] + minDistance; value[i + 1] !== null && padding > value[i + 1]; i += 1, padding = value[i] + minDistance) {\n      // eslint-disable-next-line no-param-reassign\n      value[i + 1] = alignValue(padding, this.props);\n    }\n  };\n\n  _proto.pushPreceding = function pushPreceding(value, minDistance, index) {\n    for (let i = index, padding = value[i] - minDistance; value[i - 1] !== null && padding < value[i - 1]; i -= 1, padding = value[i] - minDistance) {\n      // eslint-disable-next-line no-param-reassign\n      value[i - 1] = alignValue(padding, this.props);\n    }\n  };\n\n  _proto.axisKey = function axisKey() {\n    if (this.props.orientation === 'vertical') {\n      return 'Y';\n    } // Defaults to 'horizontal';\n\n\n    return 'X';\n  };\n\n  _proto.orthogonalAxisKey = function orthogonalAxisKey() {\n    if (this.props.orientation === 'vertical') {\n      return 'X';\n    } // Defaults to 'horizontal'\n\n\n    return 'Y';\n  };\n\n  _proto.posMinKey = function posMinKey() {\n    if (this.props.orientation === 'vertical') {\n      return this.props.invert ? 'bottom' : 'top';\n    } // Defaults to 'horizontal'\n\n\n    return this.props.invert ? 'right' : 'left';\n  };\n\n  _proto.posMaxKey = function posMaxKey() {\n    if (this.props.orientation === 'vertical') {\n      return this.props.invert ? 'top' : 'bottom';\n    } // Defaults to 'horizontal'\n\n\n    return this.props.invert ? 'left' : 'right';\n  };\n\n  _proto.sizeKey = function sizeKey() {\n    if (this.props.orientation === 'vertical') {\n      return 'clientHeight';\n    } // Defaults to 'horizontal'\n\n\n    return 'clientWidth';\n  };\n\n  _proto.fireChangeEvent = function fireChangeEvent(event) {\n    if (this.props[event]) {\n      this.props[event](prepareOutValue(this.state.value), this.state.index);\n    }\n  };\n\n  _proto.buildThumbStyle = function buildThumbStyle(offset, i) {\n    const style = {\n      position: 'absolute',\n      touchAction: 'none',\n      willChange: this.state.index >= 0 ? this.posMinKey() : undefined,\n      zIndex: this.state.zIndices.indexOf(i) + 1\n    };\n    style[this.posMinKey()] = offset + \"px\";\n    return style;\n  };\n\n  _proto.buildTrackStyle = function buildTrackStyle(min, max) {\n    const obj = {\n      position: 'absolute',\n      willChange: this.state.index >= 0 ? this.posMinKey() + \",\" + this.posMaxKey() : undefined\n    };\n    obj[this.posMinKey()] = min;\n    obj[this.posMaxKey()] = max;\n    return obj;\n  };\n\n  _proto.buildMarkStyle = function buildMarkStyle(offset) {\n    var _ref;\n\n    return _ref = {\n      position: 'absolute'\n    }, _ref[this.posMinKey()] = offset, _ref;\n  };\n\n  _proto.renderThumbs = function renderThumbs(offset) {\n    const {\n      length\n    } = offset;\n    const styles = [];\n\n    for (let i = 0; i < length; i += 1) {\n      styles[i] = this.buildThumbStyle(offset[i], i);\n    }\n\n    const res = [];\n\n    for (let i = 0; i < length; i += 1) {\n      res[i] = this.renderThumb(styles[i], i);\n    }\n\n    return res;\n  };\n\n  _proto.renderTracks = function renderTracks(offset) {\n    const tracks = [];\n    const lastIndex = offset.length - 1;\n    tracks.push(this.renderTrack(0, 0, offset[0]));\n\n    for (let i = 0; i < lastIndex; i += 1) {\n      tracks.push(this.renderTrack(i + 1, offset[i], offset[i + 1]));\n    }\n\n    tracks.push(this.renderTrack(lastIndex + 1, offset[lastIndex], this.state.upperBound));\n    return tracks;\n  };\n\n  _proto.renderMarks = function renderMarks() {\n    let {\n      marks\n    } = this.props;\n    const range = this.props.max - this.props.min + 1;\n\n    if (typeof marks === 'boolean') {\n      marks = Array.from({\n        length: range\n      }).map((_, key) => key);\n    } else if (typeof marks === 'number') {\n      marks = Array.from({\n        length: range\n      }).map((_, key) => key).filter(key => key % marks === 0);\n    }\n\n    return marks.map(parseFloat).sort((a, b) => a - b).map(mark => {\n      const offset = this.calcOffset(mark);\n      const props = {\n        key: mark,\n        className: this.props.markClassName,\n        style: this.buildMarkStyle(offset)\n      };\n      return this.props.renderMark(props);\n    });\n  };\n\n  _proto.render = function render() {\n    const offset = [];\n    const {\n      value\n    } = this.state;\n    const l = value.length;\n\n    for (let i = 0; i < l; i += 1) {\n      offset[i] = this.calcOffset(value[i], i);\n    }\n\n    const tracks = this.props.withTracks ? this.renderTracks(offset) : null;\n    const thumbs = this.renderThumbs(offset);\n    const marks = this.props.marks ? this.renderMarks() : null;\n    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_2__.createElement('div', {\n      ref: r => {\n        this.slider = r;\n        this.resizeElementRef.current = r;\n      },\n      style: {\n        position: 'relative'\n      },\n      className: this.props.className + (this.props.disabled ? ' disabled' : ''),\n      onMouseDown: this.onSliderMouseDown,\n      onClick: this.onSliderClick\n    }, tracks, thumbs, marks);\n  };\n\n  return ReactSlider;\n}(react__WEBPACK_IMPORTED_MODULE_2__.Component);\n\nReactSlider.displayName = 'ReactSlider';\nReactSlider.defaultProps = {\n  min: 0,\n  max: 100,\n  step: 1,\n  pageFn: step => step * 10,\n  minDistance: 0,\n  defaultValue: 0,\n  orientation: 'horizontal',\n  className: 'slider',\n  thumbClassName: 'thumb',\n  thumbActiveClassName: 'active',\n  trackClassName: 'track',\n  markClassName: 'mark',\n  withTracks: true,\n  pearling: false,\n  disabled: false,\n  snapDragDisabled: false,\n  invert: false,\n  marks: [],\n  renderThumb: props => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_2__.createElement(\"div\", _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0__({}, props, {\n    __self: ReactSlider,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 353,\n      columnNumber: 31\n    }\n  })),\n  renderTrack: props => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_2__.createElement(\"div\", _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0__({}, props, {\n    __self: ReactSlider,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 354,\n      columnNumber: 31\n    }\n  })),\n  renderMark: props => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_2__.createElement(\"span\", _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0__({}, props, {\n    __self: ReactSlider,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 355,\n      columnNumber: 30\n    }\n  }))\n};\nReactSlider.propTypes =  true ? {\n  /**\n   * The minimum value of the slider.\n   */\n  min: prop_types__WEBPACK_IMPORTED_MODULE_3__.number,\n\n  /**\n   * The maximum value of the slider.\n   */\n  max: prop_types__WEBPACK_IMPORTED_MODULE_3__.number,\n\n  /**\n   * Value to be added or subtracted on each step the slider makes.\n   * Must be greater than zero.\n   * `max - min` should be evenly divisible by the step value.\n   */\n  step: prop_types__WEBPACK_IMPORTED_MODULE_3__.number,\n\n  /**\n   * The result of the function is the value to be added or subtracted\n   * when the `Page Up` or `Page Down` keys are pressed.\n   *\n   * The current `step` value will be passed as the only argument.\n   * By default, paging will modify `step` by a factor of 10.\n   */\n  pageFn: prop_types__WEBPACK_IMPORTED_MODULE_3__.func,\n\n  /**\n   * The minimal distance between any pair of thumbs.\n   * Must be positive, but zero means they can sit on top of each other.\n   */\n  minDistance: prop_types__WEBPACK_IMPORTED_MODULE_3__.number,\n\n  /**\n   * Determines the initial positions of the thumbs and the number of thumbs.\n   *\n   * If a number is passed a slider with one thumb will be rendered.\n   * If an array is passed each value will determine the position of one thumb.\n   * The values in the array must be sorted.\n   */\n  defaultValue: prop_types__WEBPACK_IMPORTED_MODULE_3__.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_3__.number, prop_types__WEBPACK_IMPORTED_MODULE_3__.arrayOf(prop_types__WEBPACK_IMPORTED_MODULE_3__.number)]),\n\n  /**\n   * Like `defaultValue` but for\n   * [controlled components](http://facebook.github.io/react/docs/forms.html#controlled-components).\n   */\n  // eslint-disable-next-line zillow/react/require-default-props\n  value: prop_types__WEBPACK_IMPORTED_MODULE_3__.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_3__.number, prop_types__WEBPACK_IMPORTED_MODULE_3__.arrayOf(prop_types__WEBPACK_IMPORTED_MODULE_3__.number)]),\n\n  /**\n   * Determines whether the slider moves horizontally (from left to right)\n   * or vertically (from top to bottom).\n   */\n  orientation: prop_types__WEBPACK_IMPORTED_MODULE_3__.oneOf(['horizontal', 'vertical']),\n\n  /**\n   * The css class set on the slider node.\n   */\n  className: prop_types__WEBPACK_IMPORTED_MODULE_3__.string,\n\n  /**\n   * The css class set on each thumb node.\n   *\n   * In addition each thumb will receive a numbered css class of the form\n   * `${thumbClassName}-${i}`, e.g. `thumb-0`, `thumb-1`, ...\n   */\n  thumbClassName: prop_types__WEBPACK_IMPORTED_MODULE_3__.string,\n\n  /**\n   * The css class set on the thumb that is currently being moved.\n   */\n  thumbActiveClassName: prop_types__WEBPACK_IMPORTED_MODULE_3__.string,\n\n  /**\n   * If `true` tracks between the thumbs will be rendered.\n   */\n  withTracks: prop_types__WEBPACK_IMPORTED_MODULE_3__.bool,\n\n  /**\n   * The css class set on the tracks between the thumbs.\n   * In addition track fragment will receive a numbered css class of the form\n   * `${trackClassName}-${i}`, e.g. `track-0`, `track-1`, ...\n   */\n  trackClassName: prop_types__WEBPACK_IMPORTED_MODULE_3__.string,\n\n  /**\n   * If `true` the active thumb will push other thumbs\n   * within the constraints of `min`, `max`, `step` and `minDistance`.\n   */\n  pearling: prop_types__WEBPACK_IMPORTED_MODULE_3__.bool,\n\n  /**\n   * If `true` the thumbs can't be moved.\n   */\n  disabled: prop_types__WEBPACK_IMPORTED_MODULE_3__.bool,\n\n  /**\n   * Disables thumb move when clicking the slider track\n   */\n  snapDragDisabled: prop_types__WEBPACK_IMPORTED_MODULE_3__.bool,\n\n  /**\n   * Inverts the slider.\n   */\n  invert: prop_types__WEBPACK_IMPORTED_MODULE_3__.bool,\n\n  /**\n   * Shows passed marks on the track, if true it shows all the marks,\n   * if an array of numbers it shows just the passed marks, if a number is passed\n   * it shows just the marks in that steps: like passing 3 shows the marks 3, 6, 9\n   */\n  marks: prop_types__WEBPACK_IMPORTED_MODULE_3__.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_3__.arrayOf(prop_types__WEBPACK_IMPORTED_MODULE_3__.number), prop_types__WEBPACK_IMPORTED_MODULE_3__.bool, prop_types__WEBPACK_IMPORTED_MODULE_3__.number]),\n\n  /**\n   * The css class set on the marks.\n   */\n  markClassName: prop_types__WEBPACK_IMPORTED_MODULE_3__.string,\n\n  /**\n   * Callback called before starting to move a thumb. The callback will only be called if the\n   * action will result in a change. The function will be called with two arguments, the first\n   * being the initial value(s) the second being thumb index.\n   */\n  // eslint-disable-next-line max-len\n  // eslint-disable-next-line zillow/react/require-default-props, zillow/react/no-unused-prop-types\n  onBeforeChange: prop_types__WEBPACK_IMPORTED_MODULE_3__.func,\n\n  /**\n   * Callback called on every value change.\n   * The function will be called with two arguments, the first being the new value(s)\n   * the second being thumb index.\n   */\n  // eslint-disable-next-line max-len\n  // eslint-disable-next-line zillow/react/require-default-props, zillow/react/no-unused-prop-types\n  onChange: prop_types__WEBPACK_IMPORTED_MODULE_3__.func,\n\n  /**\n   * Callback called only after moving a thumb has ended. The callback will only be called if\n   * the action resulted in a change. The function will be called with two arguments, the\n   * first being the result value(s) the second being thumb index.\n   */\n  // eslint-disable-next-line max-len\n  // eslint-disable-next-line zillow/react/require-default-props, zillow/react/no-unused-prop-types\n  onAfterChange: prop_types__WEBPACK_IMPORTED_MODULE_3__.func,\n\n  /**\n   * Callback called when the the slider is clicked (thumb or tracks).\n   * Receives the value at the clicked position as argument.\n   */\n  // eslint-disable-next-line zillow/react/require-default-props\n  onSliderClick: prop_types__WEBPACK_IMPORTED_MODULE_3__.func,\n\n  /**\n   * aria-label for screen-readers to apply to the thumbs.\n   * Use an array for more than one thumb.\n   * The length of the array must match the number of thumbs in the value array.\n   */\n  // eslint-disable-next-line zillow/react/require-default-props\n  ariaLabel: prop_types__WEBPACK_IMPORTED_MODULE_3__.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_3__.string, prop_types__WEBPACK_IMPORTED_MODULE_3__.arrayOf(prop_types__WEBPACK_IMPORTED_MODULE_3__.string)]),\n\n  /**\n   * aria-labelledby for screen-readers to apply to the thumbs.\n   * Used when slider rendered with separate label.\n   * Use an array for more than one thumb.\n   * The length of the array must match the number of thumbs in the value array.\n   */\n  // eslint-disable-next-line zillow/react/require-default-props\n  ariaLabelledby: prop_types__WEBPACK_IMPORTED_MODULE_3__.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_3__.string, prop_types__WEBPACK_IMPORTED_MODULE_3__.arrayOf(prop_types__WEBPACK_IMPORTED_MODULE_3__.string)]),\n\n  /**\n   * aria-valuetext for screen-readers.\n   * Can be a static string, or a function that returns a string.\n   * The function will be passed a single argument,\n   * an object with the following properties:\n   *\n   *     state => `Value: ${state.value}`\n   *\n   * - `state.index` {`number`} the index of the thumb\n   * - `state.value` {`number` | `array`} the current value state\n   * - `state.valueNow` {`number`} the value of the thumb (i.e. aria-valuenow)\n   */\n  // eslint-disable-next-line zillow/react/require-default-props\n  ariaValuetext: prop_types__WEBPACK_IMPORTED_MODULE_3__.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_3__.string, prop_types__WEBPACK_IMPORTED_MODULE_3__.func]),\n\n  /**\n   * Provide a custom render function for the track node.\n   * The render function will be passed two arguments,\n   * an object with props that should be added to your handle node,\n   * and an object with track and slider state:\n   *\n   *     (props, state) => <div {...props} />\n   *\n   * - `props` {`object`} props to be spread into your track node\n   * - `state.index` {`number`} the index of the track\n   * - `state.value` {`number` | `array`} the current value state\n   */\n  renderTrack: prop_types__WEBPACK_IMPORTED_MODULE_3__.func,\n\n  /**\n   * Provide a custom render function for dynamic thumb content.\n   * The render function will be passed two arguments,\n   * an object with props that should be added to your thumb node,\n   * and an object with thumb and slider state:\n   *\n   *     (props, state) => <div {...props} />\n   *\n   * - `props` {`object`} props to be spread into your thumb node\n   * - `state.index` {`number`} the index of the thumb\n   * - `state.value` {`number` | `array`} the current value state\n   * - `state.valueNow` {`number`} the value of the thumb (i.e. aria-valuenow)\n   */\n  // eslint-disable-next-line zillow/react/require-default-props\n  renderThumb: prop_types__WEBPACK_IMPORTED_MODULE_3__.func,\n\n  /**\n   * Provide a custom render function for the mark node.\n   * The render function will be passed one argument,\n   * an object with props that should be added to your handle node\n   *\n   *     (props) => <span {...props} />\n   *\n   * - `props` {`object`} props to be spread into your track node\n   */\n  renderMark: prop_types__WEBPACK_IMPORTED_MODULE_3__.func\n} : 0;\nvar ReactSlider$1 = ReactSlider;\n\n\n//# sourceMappingURL=ReactSlider.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3Qtc2xpZGVyL2Rpc3QvZXMvZGV2L2NvbXBvbmVudHMvUmVhY3RTbGlkZXIvUmVhY3RTbGlkZXIubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQXNEO0FBQ1k7QUFDeEM7QUFDUzs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLFlBQVk7QUFDOUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLFlBQVk7QUFDOUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsRUFBRSxpRUFBYzs7QUFFaEI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTtBQUNBLE9BQU87O0FBRVA7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0E7QUFDQSxPQUFPOztBQUVQOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBO0FBQ0EsT0FBTzs7QUFFUDs7QUFFQSxzQ0FBc0M7O0FBRXRDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBOztBQUVBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMENBQTBDLDRDQUFlO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7O0FBRUEsb0NBQW9DOztBQUVwQztBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7O0FBRXBEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRTtBQUMvRTs7QUFFQTtBQUNBLHFDQUFxQzs7QUFFckMsb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTSxjQUFjOztBQUVwQiw2Q0FBNkM7O0FBRTdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5REFBeUQ7O0FBRXpEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlEQUF5RDs7QUFFekQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNLFNBQVM7O0FBRWY7O0FBRUE7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEI7QUFDMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkJBQTZCOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7O0FBR0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0RBQXNELGlEQUFpRDtBQUN2RztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBEQUEwRCxpREFBaUQ7QUFDM0c7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUEsb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTs7QUFFQTs7QUFFQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLGVBQWU7QUFDbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdEQUFtQjtBQUMzQztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxDQUFDLENBQUMsNENBQWU7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsZ0RBQW1CLFFBQVEsMkRBQVEsR0FBRztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gscUNBQXFDLGdEQUFtQixRQUFRLDJEQUFRLEdBQUc7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILG9DQUFvQyxnREFBbUIsU0FBUywyREFBUSxHQUFHO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLHdCQUF3QixLQUFxQztBQUM3RDtBQUNBO0FBQ0E7QUFDQSxPQUFPLDhDQUFnQjs7QUFFdkI7QUFDQTtBQUNBO0FBQ0EsT0FBTyw4Q0FBZ0I7O0FBRXZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDhDQUFnQjs7QUFFeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDRDQUFjOztBQUV4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsOENBQWdCOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpREFBbUIsRUFBRSw4Q0FBZ0IsRUFBRSwrQ0FBaUIsQ0FBQyw4Q0FBZ0I7O0FBRXpGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLGlEQUFtQixFQUFFLDhDQUFnQixFQUFFLCtDQUFpQixDQUFDLDhDQUFnQjs7QUFFbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDZDQUFlOztBQUU5QjtBQUNBO0FBQ0E7QUFDQSxhQUFhLDhDQUFnQjs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGVBQWUsR0FBRyxFQUFFO0FBQzVCO0FBQ0Esa0JBQWtCLDhDQUFnQjs7QUFFbEM7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDhDQUFnQjs7QUFFeEM7QUFDQTtBQUNBO0FBQ0EsY0FBYyw0Q0FBYzs7QUFFNUI7QUFDQTtBQUNBO0FBQ0EsUUFBUSxlQUFlLEdBQUcsRUFBRTtBQUM1QjtBQUNBLGtCQUFrQiw4Q0FBZ0I7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw0Q0FBYzs7QUFFMUI7QUFDQTtBQUNBO0FBQ0EsWUFBWSw0Q0FBYzs7QUFFMUI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDRDQUFjOztBQUVsQztBQUNBO0FBQ0E7QUFDQSxVQUFVLDRDQUFjOztBQUV4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxpREFBbUIsRUFBRSwrQ0FBaUIsQ0FBQyw4Q0FBZ0IsR0FBRyw0Q0FBYyxFQUFFLDhDQUFnQjs7QUFFbkc7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDhDQUFnQjs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsNENBQWM7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw0Q0FBYzs7QUFFMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsNENBQWM7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsNENBQWM7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaURBQW1CLEVBQUUsOENBQWdCLEVBQUUsK0NBQWlCLENBQUMsOENBQWdCOztBQUV0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpREFBbUIsRUFBRSw4Q0FBZ0IsRUFBRSwrQ0FBaUIsQ0FBQyw4Q0FBZ0I7O0FBRTNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixZQUFZO0FBQ3hDO0FBQ0Esc0JBQXNCLFVBQVU7QUFDaEMsc0JBQXNCLG9CQUFvQjtBQUMxQyx5QkFBeUIsVUFBVTtBQUNuQztBQUNBO0FBQ0EsaUJBQWlCLGlEQUFtQixFQUFFLDhDQUFnQixFQUFFLDRDQUFjOztBQUV0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsVUFBVTtBQUMzQztBQUNBLGdCQUFnQixVQUFVO0FBQzFCLHNCQUFzQixVQUFVO0FBQ2hDLHNCQUFzQixvQkFBb0I7QUFDMUM7QUFDQSxlQUFlLDRDQUFjOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsVUFBVTtBQUMzQztBQUNBLGdCQUFnQixVQUFVO0FBQzFCLHNCQUFzQixVQUFVO0FBQ2hDLHNCQUFzQixvQkFBb0I7QUFDMUMseUJBQXlCLFVBQVU7QUFDbkM7QUFDQTtBQUNBLGVBQWUsNENBQWM7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsVUFBVTtBQUNyQztBQUNBLGdCQUFnQixVQUFVO0FBQzFCO0FBQ0EsY0FBYyw0Q0FBYztBQUM1QixFQUFFLEVBQUUsQ0FBRTtBQUNOOztBQUVvQztBQUNwQyIsInNvdXJjZXMiOlsid2VicGFjazovL2ZyZWVpby1uZXh0anMvLi9ub2RlX21vZHVsZXMvcmVhY3Qtc2xpZGVyL2Rpc3QvZXMvZGV2L2NvbXBvbmVudHMvUmVhY3RTbGlkZXIvUmVhY3RTbGlkZXIubWpzPzg5NWIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF9leHRlbmRzIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXh0ZW5kcyc7XG5pbXBvcnQgX2luaGVyaXRzTG9vc2UgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbmhlcml0c0xvb3NlJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuXG52YXIgX2pzeEZpbGVOYW1lID0gXCIvVXNlcnMva3Jpc2UvZ2l0aHViL3JlYWN0LXNsaWRlci9zcmMvY29tcG9uZW50cy9SZWFjdFNsaWRlci9SZWFjdFNsaWRlci5qc3hcIjtcbi8qKlxuICogVG8gcHJldmVudCB0ZXh0IHNlbGVjdGlvbiB3aGlsZSBkcmFnZ2luZy5cbiAqIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNTQyOTgyNy9ob3ctY2FuLWktcHJldmVudC10ZXh0LWVsZW1lbnQtc2VsZWN0aW9uLXdpdGgtY3Vyc29yLWRyYWdcbiAqL1xuXG5mdW5jdGlvbiBwYXVzZUV2ZW50KGUpIHtcbiAgaWYgKGUgJiYgZS5zdG9wUHJvcGFnYXRpb24pIHtcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICB9XG5cbiAgaWYgKGUgJiYgZS5wcmV2ZW50RGVmYXVsdCkge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gc3RvcFByb3BhZ2F0aW9uKGUpIHtcbiAgaWYgKGUuc3RvcFByb3BhZ2F0aW9uKSB7XG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzYW5pdGl6ZUluVmFsdWUoeCkge1xuICBpZiAoeCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoeCkgPyB4LnNsaWNlKCkgOiBbeF07XG59XG5cbmZ1bmN0aW9uIHByZXBhcmVPdXRWYWx1ZSh4KSB7XG4gIHJldHVybiB4ICE9PSBudWxsICYmIHgubGVuZ3RoID09PSAxID8geFswXSA6IHguc2xpY2UoKTtcbn1cblxuZnVuY3Rpb24gdHJpbVN1Y2NlZWRpbmcobGVuZ3RoLCBuZXh0VmFsdWUsIG1pbkRpc3RhbmNlLCBtYXgpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIGNvbnN0IHBhZGRpbmcgPSBtYXggLSBpICogbWluRGlzdGFuY2U7XG5cbiAgICBpZiAobmV4dFZhbHVlW2xlbmd0aCAtIDEgLSBpXSA+IHBhZGRpbmcpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgbmV4dFZhbHVlW2xlbmd0aCAtIDEgLSBpXSA9IHBhZGRpbmc7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHRyaW1QcmVjZWRpbmcobGVuZ3RoLCBuZXh0VmFsdWUsIG1pbkRpc3RhbmNlLCBtaW4pIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIGNvbnN0IHBhZGRpbmcgPSBtaW4gKyBpICogbWluRGlzdGFuY2U7XG5cbiAgICBpZiAobmV4dFZhbHVlW2ldIDwgcGFkZGluZykge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICBuZXh0VmFsdWVbaV0gPSBwYWRkaW5nO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZGRIYW5kbGVycyhldmVudE1hcCkge1xuICBPYmplY3Qua2V5cyhldmVudE1hcCkuZm9yRWFjaChrZXkgPT4ge1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKGtleSwgZXZlbnRNYXBba2V5XSwgZmFsc2UpO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUhhbmRsZXJzKGV2ZW50TWFwKSB7XG4gIE9iamVjdC5rZXlzKGV2ZW50TWFwKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoa2V5LCBldmVudE1hcFtrZXldLCBmYWxzZSk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gdHJpbUFsaWduVmFsdWUodmFsLCBwcm9wcykge1xuICByZXR1cm4gYWxpZ25WYWx1ZSh0cmltVmFsdWUodmFsLCBwcm9wcyksIHByb3BzKTtcbn1cblxuZnVuY3Rpb24gYWxpZ25WYWx1ZSh2YWwsIHByb3BzKSB7XG4gIGNvbnN0IHZhbE1vZFN0ZXAgPSAodmFsIC0gcHJvcHMubWluKSAlIHByb3BzLnN0ZXA7XG4gIGxldCBhbGlnbmVkVmFsdWUgPSB2YWwgLSB2YWxNb2RTdGVwO1xuXG4gIGlmIChNYXRoLmFicyh2YWxNb2RTdGVwKSAqIDIgPj0gcHJvcHMuc3RlcCkge1xuICAgIGFsaWduZWRWYWx1ZSArPSB2YWxNb2RTdGVwID4gMCA/IHByb3BzLnN0ZXAgOiAtcHJvcHMuc3RlcDtcbiAgfVxuXG4gIHJldHVybiBwYXJzZUZsb2F0KGFsaWduZWRWYWx1ZS50b0ZpeGVkKDUpKTtcbn1cblxuZnVuY3Rpb24gdHJpbVZhbHVlKHZhbCwgcHJvcHMpIHtcbiAgbGV0IHRyaW1tZWQgPSB2YWw7XG5cbiAgaWYgKHRyaW1tZWQgPD0gcHJvcHMubWluKSB7XG4gICAgdHJpbW1lZCA9IHByb3BzLm1pbjtcbiAgfVxuXG4gIGlmICh0cmltbWVkID49IHByb3BzLm1heCkge1xuICAgIHRyaW1tZWQgPSBwcm9wcy5tYXg7XG4gIH1cblxuICByZXR1cm4gdHJpbW1lZDtcbn1cblxubGV0IFJlYWN0U2xpZGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0c0xvb3NlKFJlYWN0U2xpZGVyLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBSZWFjdFNsaWRlcihfcHJvcHMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfdGhpcyA9IF9SZWFjdCRDb21wb25lbnQuY2FsbCh0aGlzLCBfcHJvcHMpIHx8IHRoaXM7XG5cbiAgICBfdGhpcy5vbktleVVwID0gKCkgPT4ge1xuICAgICAgX3RoaXMub25FbmQoKTtcbiAgICB9O1xuXG4gICAgX3RoaXMub25Nb3VzZVVwID0gKCkgPT4ge1xuICAgICAgX3RoaXMub25FbmQoX3RoaXMuZ2V0TW91c2VFdmVudE1hcCgpKTtcbiAgICB9O1xuXG4gICAgX3RoaXMub25Ub3VjaEVuZCA9IGUgPT4ge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICBfdGhpcy5vbkVuZChfdGhpcy5nZXRUb3VjaEV2ZW50TWFwKCkpO1xuICAgIH07XG5cbiAgICBfdGhpcy5vbkJsdXIgPSAoKSA9PiB7XG4gICAgICBfdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIGluZGV4OiAtMVxuICAgICAgfSwgX3RoaXMub25FbmQoX3RoaXMuZ2V0S2V5RG93bkV2ZW50TWFwKCkpKTtcbiAgICB9O1xuXG4gICAgX3RoaXMub25Nb3VzZU1vdmUgPSBlID0+IHtcbiAgICAgIC8vIFByZXZlbnQgY29udHJvbGxlZCB1cGRhdGVzIGZyb20gaGFwcGVuaW5nIHdoaWxlIG1vdXNlIGlzIG1vdmluZ1xuICAgICAgX3RoaXMuc2V0U3RhdGUoe1xuICAgICAgICBwZW5kaW5nOiB0cnVlXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcG9zaXRpb24gPSBfdGhpcy5nZXRNb3VzZVBvc2l0aW9uKGUpO1xuXG4gICAgICBjb25zdCBkaWZmUG9zaXRpb24gPSBfdGhpcy5nZXREaWZmUG9zaXRpb24ocG9zaXRpb25bMF0pO1xuXG4gICAgICBjb25zdCBuZXdWYWx1ZSA9IF90aGlzLmdldFZhbHVlRnJvbVBvc2l0aW9uKGRpZmZQb3NpdGlvbik7XG5cbiAgICAgIF90aGlzLm1vdmUobmV3VmFsdWUpO1xuICAgIH07XG5cbiAgICBfdGhpcy5vblRvdWNoTW92ZSA9IGUgPT4ge1xuICAgICAgaWYgKGUudG91Y2hlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gUHJldmVudCBjb250cm9sbGVkIHVwZGF0ZXMgZnJvbSBoYXBwZW5kaW5nIHdoaWxlIHRvdWNoIGlzIG1vdmluZ1xuXG5cbiAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgcGVuZGluZzogdHJ1ZVxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gX3RoaXMuZ2V0VG91Y2hQb3NpdGlvbihlKTtcblxuICAgICAgaWYgKHR5cGVvZiBfdGhpcy5pc1Njcm9sbGluZyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29uc3QgZGlmZk1haW5EaXIgPSBwb3NpdGlvblswXSAtIF90aGlzLnN0YXJ0UG9zaXRpb25bMF07XG4gICAgICAgIGNvbnN0IGRpZmZTY3JvbGxEaXIgPSBwb3NpdGlvblsxXSAtIF90aGlzLnN0YXJ0UG9zaXRpb25bMV07XG4gICAgICAgIF90aGlzLmlzU2Nyb2xsaW5nID0gTWF0aC5hYnMoZGlmZlNjcm9sbERpcikgPiBNYXRoLmFicyhkaWZmTWFpbkRpcik7XG4gICAgICB9XG5cbiAgICAgIGlmIChfdGhpcy5pc1Njcm9sbGluZykge1xuICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgaW5kZXg6IC0xXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZGlmZlBvc2l0aW9uID0gX3RoaXMuZ2V0RGlmZlBvc2l0aW9uKHBvc2l0aW9uWzBdKTtcblxuICAgICAgY29uc3QgbmV3VmFsdWUgPSBfdGhpcy5nZXRWYWx1ZUZyb21Qb3NpdGlvbihkaWZmUG9zaXRpb24pO1xuXG4gICAgICBfdGhpcy5tb3ZlKG5ld1ZhbHVlKTtcbiAgICB9O1xuXG4gICAgX3RoaXMub25LZXlEb3duID0gZSA9PiB7XG4gICAgICBpZiAoZS5jdHJsS2V5IHx8IGUuc2hpZnRLZXkgfHwgZS5hbHRLZXkgfHwgZS5tZXRhS2V5KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gUHJldmVudCBjb250cm9sbGVkIHVwZGF0ZXMgZnJvbSBoYXBwZW5pbmcgd2hpbGUgYSBrZXkgaXMgcHJlc3NlZFxuXG5cbiAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgcGVuZGluZzogdHJ1ZVxuICAgICAgfSk7XG5cbiAgICAgIHN3aXRjaCAoZS5rZXkpIHtcbiAgICAgICAgY2FzZSAnQXJyb3dMZWZ0JzpcbiAgICAgICAgY2FzZSAnQXJyb3dEb3duJzpcbiAgICAgICAgY2FzZSAnTGVmdCc6XG4gICAgICAgIGNhc2UgJ0Rvd24nOlxuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgIF90aGlzLm1vdmVEb3duQnlTdGVwKCk7XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdBcnJvd1JpZ2h0JzpcbiAgICAgICAgY2FzZSAnQXJyb3dVcCc6XG4gICAgICAgIGNhc2UgJ1JpZ2h0JzpcbiAgICAgICAgY2FzZSAnVXAnOlxuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgIF90aGlzLm1vdmVVcEJ5U3RlcCgpO1xuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnSG9tZSc6XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgX3RoaXMubW92ZShfdGhpcy5wcm9wcy5taW4pO1xuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnRW5kJzpcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICBfdGhpcy5tb3ZlKF90aGlzLnByb3BzLm1heCk7XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdQYWdlRG93bic6XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgX3RoaXMubW92ZURvd25CeVN0ZXAoX3RoaXMucHJvcHMucGFnZUZuKF90aGlzLnByb3BzLnN0ZXApKTtcblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ1BhZ2VVcCc6XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgX3RoaXMubW92ZVVwQnlTdGVwKF90aGlzLnByb3BzLnBhZ2VGbihfdGhpcy5wcm9wcy5zdGVwKSk7XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3RoaXMub25TbGlkZXJNb3VzZURvd24gPSBlID0+IHtcbiAgICAgIC8vIGRvIG5vdGhpbmcgaWYgZGlzYWJsZWQgb3IgcmlnaHQgY2xpY2tcbiAgICAgIGlmIChfdGhpcy5wcm9wcy5kaXNhYmxlZCB8fCBlLmJ1dHRvbiA9PT0gMikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIFByZXZlbnQgY29udHJvbGxlZCB1cGRhdGVzIGZyb20gaGFwcGVuaW5nIHdoaWxlIG1vdXNlIGlzIG1vdmluZ1xuXG5cbiAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgcGVuZGluZzogdHJ1ZVxuICAgICAgfSk7XG5cbiAgICAgIGlmICghX3RoaXMucHJvcHMuc25hcERyYWdEaXNhYmxlZCkge1xuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IF90aGlzLmdldE1vdXNlUG9zaXRpb24oZSk7XG5cbiAgICAgICAgX3RoaXMuZm9yY2VWYWx1ZUZyb21Qb3NpdGlvbihwb3NpdGlvblswXSwgaSA9PiB7XG4gICAgICAgICAgX3RoaXMuc3RhcnQoaSwgcG9zaXRpb25bMF0pO1xuXG4gICAgICAgICAgYWRkSGFuZGxlcnMoX3RoaXMuZ2V0TW91c2VFdmVudE1hcCgpKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHBhdXNlRXZlbnQoZSk7XG4gICAgfTtcblxuICAgIF90aGlzLm9uU2xpZGVyQ2xpY2sgPSBlID0+IHtcbiAgICAgIGlmIChfdGhpcy5wcm9wcy5kaXNhYmxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChfdGhpcy5wcm9wcy5vblNsaWRlckNsaWNrICYmICFfdGhpcy5oYXNNb3ZlZCkge1xuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IF90aGlzLmdldE1vdXNlUG9zaXRpb24oZSk7XG5cbiAgICAgICAgY29uc3QgdmFsdWVBdFBvcyA9IHRyaW1BbGlnblZhbHVlKF90aGlzLmNhbGNWYWx1ZShfdGhpcy5jYWxjT2Zmc2V0RnJvbVBvc2l0aW9uKHBvc2l0aW9uWzBdKSksIF90aGlzLnByb3BzKTtcblxuICAgICAgICBfdGhpcy5wcm9wcy5vblNsaWRlckNsaWNrKHZhbHVlQXRQb3MpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfdGhpcy5jcmVhdGVPbktleURvd24gPSBpID0+IGUgPT4ge1xuICAgICAgaWYgKF90aGlzLnByb3BzLmRpc2FibGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgX3RoaXMuc3RhcnQoaSk7XG5cbiAgICAgIGFkZEhhbmRsZXJzKF90aGlzLmdldEtleURvd25FdmVudE1hcCgpKTtcbiAgICAgIHBhdXNlRXZlbnQoZSk7XG4gICAgfTtcblxuICAgIF90aGlzLmNyZWF0ZU9uTW91c2VEb3duID0gaSA9PiBlID0+IHtcbiAgICAgIC8vIGRvIG5vdGhpbmcgaWYgZGlzYWJsZWQgb3IgcmlnaHQgY2xpY2tcbiAgICAgIGlmIChfdGhpcy5wcm9wcy5kaXNhYmxlZCB8fCBlLmJ1dHRvbiA9PT0gMikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIFByZXZlbnQgY29udHJvbGxlZCB1cGRhdGVzIGZyb20gaGFwcGVuZGluZyB3aGlsZSBtb3VzZSBpcyBtb3ZpbmdcblxuXG4gICAgICBfdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIHBlbmRpbmc6IHRydWVcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBwb3NpdGlvbiA9IF90aGlzLmdldE1vdXNlUG9zaXRpb24oZSk7XG5cbiAgICAgIF90aGlzLnN0YXJ0KGksIHBvc2l0aW9uWzBdKTtcblxuICAgICAgYWRkSGFuZGxlcnMoX3RoaXMuZ2V0TW91c2VFdmVudE1hcCgpKTtcbiAgICAgIHBhdXNlRXZlbnQoZSk7XG4gICAgfTtcblxuICAgIF90aGlzLmNyZWF0ZU9uVG91Y2hTdGFydCA9IGkgPT4gZSA9PiB7XG4gICAgICBpZiAoX3RoaXMucHJvcHMuZGlzYWJsZWQgfHwgZS50b3VjaGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBQcmV2ZW50IGNvbnRyb2xsZWQgdXBkYXRlcyBmcm9tIGhhcHBlbmRpbmcgd2hpbGUgdG91Y2ggaXMgbW92aW5nXG5cblxuICAgICAgX3RoaXMuc2V0U3RhdGUoe1xuICAgICAgICBwZW5kaW5nOiB0cnVlXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcG9zaXRpb24gPSBfdGhpcy5nZXRUb3VjaFBvc2l0aW9uKGUpO1xuXG4gICAgICBfdGhpcy5zdGFydFBvc2l0aW9uID0gcG9zaXRpb247IC8vIGRvbid0IGtub3cgeWV0IGlmIHRoZSB1c2VyIGlzIHRyeWluZyB0byBzY3JvbGxcblxuICAgICAgX3RoaXMuaXNTY3JvbGxpbmcgPSB1bmRlZmluZWQ7XG5cbiAgICAgIF90aGlzLnN0YXJ0KGksIHBvc2l0aW9uWzBdKTtcblxuICAgICAgYWRkSGFuZGxlcnMoX3RoaXMuZ2V0VG91Y2hFdmVudE1hcCgpKTtcbiAgICAgIHN0b3BQcm9wYWdhdGlvbihlKTtcbiAgICB9O1xuXG4gICAgX3RoaXMuaGFuZGxlUmVzaXplID0gKCkgPT4ge1xuICAgICAgLy8gc2V0VGltZW91dCBvZiAwIGdpdmVzIGVsZW1lbnQgZW5vdWdoIHRpbWUgdG8gaGF2ZSBhc3N1bWVkIGl0cyBuZXcgc2l6ZSBpZlxuICAgICAgLy8gaXQgaXMgYmVpbmcgcmVzaXplZFxuICAgICAgY29uc3QgcmVzaXplVGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgLy8gZHJvcCB0aGlzIHRpbWVvdXQgZnJvbSBwZW5kaW5nUmVzaXplVGltZW91dHMgdG8gcmVkdWNlIG1lbW9yeSB1c2FnZVxuICAgICAgICBfdGhpcy5wZW5kaW5nUmVzaXplVGltZW91dHMuc2hpZnQoKTtcblxuICAgICAgICBfdGhpcy5yZXNpemUoKTtcbiAgICAgIH0sIDApO1xuXG4gICAgICBfdGhpcy5wZW5kaW5nUmVzaXplVGltZW91dHMucHVzaChyZXNpemVUaW1lb3V0KTtcbiAgICB9O1xuXG4gICAgX3RoaXMucmVuZGVyVGh1bWIgPSAoc3R5bGUsIGkpID0+IHtcbiAgICAgIGNvbnN0IGNsYXNzTmFtZSA9IF90aGlzLnByb3BzLnRodW1iQ2xhc3NOYW1lICsgXCIgXCIgKyBfdGhpcy5wcm9wcy50aHVtYkNsYXNzTmFtZSArIFwiLVwiICsgaSArIFwiIFwiICsgKF90aGlzLnN0YXRlLmluZGV4ID09PSBpID8gX3RoaXMucHJvcHMudGh1bWJBY3RpdmVDbGFzc05hbWUgOiAnJyk7XG4gICAgICBjb25zdCBwcm9wcyA9IHtcbiAgICAgICAgJ3JlZic6IHIgPT4ge1xuICAgICAgICAgIF90aGlzW1widGh1bWJcIiArIGldID0gcjtcbiAgICAgICAgfSxcbiAgICAgICAgJ2tleSc6IF90aGlzLnByb3BzLnRodW1iQ2xhc3NOYW1lICsgXCItXCIgKyBpLFxuICAgICAgICBjbGFzc05hbWUsXG4gICAgICAgIHN0eWxlLFxuICAgICAgICAnb25Nb3VzZURvd24nOiBfdGhpcy5jcmVhdGVPbk1vdXNlRG93bihpKSxcbiAgICAgICAgJ29uVG91Y2hTdGFydCc6IF90aGlzLmNyZWF0ZU9uVG91Y2hTdGFydChpKSxcbiAgICAgICAgJ29uRm9jdXMnOiBfdGhpcy5jcmVhdGVPbktleURvd24oaSksXG4gICAgICAgICd0YWJJbmRleCc6IDAsXG4gICAgICAgICdyb2xlJzogJ3NsaWRlcicsXG4gICAgICAgICdhcmlhLW9yaWVudGF0aW9uJzogX3RoaXMucHJvcHMub3JpZW50YXRpb24sXG4gICAgICAgICdhcmlhLXZhbHVlbm93JzogX3RoaXMuc3RhdGUudmFsdWVbaV0sXG4gICAgICAgICdhcmlhLXZhbHVlbWluJzogX3RoaXMucHJvcHMubWluLFxuICAgICAgICAnYXJpYS12YWx1ZW1heCc6IF90aGlzLnByb3BzLm1heCxcbiAgICAgICAgJ2FyaWEtbGFiZWwnOiBBcnJheS5pc0FycmF5KF90aGlzLnByb3BzLmFyaWFMYWJlbCkgPyBfdGhpcy5wcm9wcy5hcmlhTGFiZWxbaV0gOiBfdGhpcy5wcm9wcy5hcmlhTGFiZWwsXG4gICAgICAgICdhcmlhLWxhYmVsbGVkYnknOiBBcnJheS5pc0FycmF5KF90aGlzLnByb3BzLmFyaWFMYWJlbGxlZGJ5KSA/IF90aGlzLnByb3BzLmFyaWFMYWJlbGxlZGJ5W2ldIDogX3RoaXMucHJvcHMuYXJpYUxhYmVsbGVkYnksXG4gICAgICAgICdhcmlhLWRpc2FibGVkJzogX3RoaXMucHJvcHMuZGlzYWJsZWRcbiAgICAgIH07XG4gICAgICBjb25zdCBzdGF0ZSA9IHtcbiAgICAgICAgaW5kZXg6IGksXG4gICAgICAgIHZhbHVlOiBwcmVwYXJlT3V0VmFsdWUoX3RoaXMuc3RhdGUudmFsdWUpLFxuICAgICAgICB2YWx1ZU5vdzogX3RoaXMuc3RhdGUudmFsdWVbaV1cbiAgICAgIH07XG5cbiAgICAgIGlmIChfdGhpcy5wcm9wcy5hcmlhVmFsdWV0ZXh0KSB7XG4gICAgICAgIHByb3BzWydhcmlhLXZhbHVldGV4dCddID0gdHlwZW9mIF90aGlzLnByb3BzLmFyaWFWYWx1ZXRleHQgPT09ICdzdHJpbmcnID8gX3RoaXMucHJvcHMuYXJpYVZhbHVldGV4dCA6IF90aGlzLnByb3BzLmFyaWFWYWx1ZXRleHQoc3RhdGUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX3RoaXMucHJvcHMucmVuZGVyVGh1bWIocHJvcHMsIHN0YXRlKTtcbiAgICB9O1xuXG4gICAgX3RoaXMucmVuZGVyVHJhY2sgPSAoaSwgb2Zmc2V0RnJvbSwgb2Zmc2V0VG8pID0+IHtcbiAgICAgIGNvbnN0IHByb3BzID0ge1xuICAgICAgICBrZXk6IF90aGlzLnByb3BzLnRyYWNrQ2xhc3NOYW1lICsgXCItXCIgKyBpLFxuICAgICAgICBjbGFzc05hbWU6IF90aGlzLnByb3BzLnRyYWNrQ2xhc3NOYW1lICsgXCIgXCIgKyBfdGhpcy5wcm9wcy50cmFja0NsYXNzTmFtZSArIFwiLVwiICsgaSxcbiAgICAgICAgc3R5bGU6IF90aGlzLmJ1aWxkVHJhY2tTdHlsZShvZmZzZXRGcm9tLCBfdGhpcy5zdGF0ZS51cHBlckJvdW5kIC0gb2Zmc2V0VG8pXG4gICAgICB9O1xuICAgICAgY29uc3Qgc3RhdGUgPSB7XG4gICAgICAgIGluZGV4OiBpLFxuICAgICAgICB2YWx1ZTogcHJlcGFyZU91dFZhbHVlKF90aGlzLnN0YXRlLnZhbHVlKVxuICAgICAgfTtcbiAgICAgIHJldHVybiBfdGhpcy5wcm9wcy5yZW5kZXJUcmFjayhwcm9wcywgc3RhdGUpO1xuICAgIH07XG5cbiAgICBsZXQgdmFsdWUgPSBzYW5pdGl6ZUluVmFsdWUoX3Byb3BzLnZhbHVlKTtcblxuICAgIGlmICghdmFsdWUubGVuZ3RoKSB7XG4gICAgICB2YWx1ZSA9IHNhbml0aXplSW5WYWx1ZShfcHJvcHMuZGVmYXVsdFZhbHVlKTtcbiAgICB9IC8vIGFycmF5IGZvciBzdG9yaW5nIHJlc2l6ZSB0aW1lb3V0cyBpZHNcblxuXG4gICAgX3RoaXMucGVuZGluZ1Jlc2l6ZVRpbWVvdXRzID0gW107XG4gICAgY29uc3QgekluZGljZXMgPSBbXTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIHZhbHVlW2ldID0gdHJpbUFsaWduVmFsdWUodmFsdWVbaV0sIF9wcm9wcyk7XG4gICAgICB6SW5kaWNlcy5wdXNoKGkpO1xuICAgIH1cblxuICAgIF90aGlzLnJlc2l6ZU9ic2VydmVyID0gbnVsbDtcbiAgICBfdGhpcy5yZXNpemVFbGVtZW50UmVmID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZVJlZigpO1xuICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgaW5kZXg6IC0xLFxuICAgICAgdXBwZXJCb3VuZDogMCxcbiAgICAgIHNsaWRlckxlbmd0aDogMCxcbiAgICAgIHZhbHVlLFxuICAgICAgekluZGljZXNcbiAgICB9O1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBSZWFjdFNsaWRlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzLnJlc2l6ZU9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKHRoaXMuaGFuZGxlUmVzaXplKTtcbiAgICAgIHRoaXMucmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLnJlc2l6ZUVsZW1lbnRSZWYuY3VycmVudCk7XG4gICAgICB0aGlzLnJlc2l6ZSgpO1xuICAgIH1cbiAgfSAvLyBLZWVwIHRoZSBpbnRlcm5hbCBgdmFsdWVgIGNvbnNpc3RlbnQgd2l0aCBhbiBvdXRzaWRlIGB2YWx1ZWAgaWYgcHJlc2VudC5cbiAgLy8gVGhpcyBiYXNpY2FsbHkgYWxsb3dzIHRoZSBzbGlkZXIgdG8gYmUgYSBjb250cm9sbGVkIGNvbXBvbmVudC5cbiAgO1xuXG4gIFJlYWN0U2xpZGVyLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9IGZ1bmN0aW9uIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhwcm9wcywgc3RhdGUpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHNhbml0aXplSW5WYWx1ZShwcm9wcy52YWx1ZSk7XG5cbiAgICBpZiAoIXZhbHVlLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSAvLyBEbyBub3QgYWxsb3cgY29udHJvbGxlZCB1cGF0ZXMgdG8gaGFwcGVuIHdoaWxlIHdlIGhhdmUgcGVuZGluZyB1cGRhdGVzXG5cblxuICAgIGlmIChzdGF0ZS5wZW5kaW5nKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6IHZhbHVlLm1hcChpdGVtID0+IHRyaW1BbGlnblZhbHVlKGl0ZW0sIHByb3BzKSlcbiAgICB9O1xuICB9O1xuXG4gIF9wcm90by5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiBjb21wb25lbnREaWRVcGRhdGUoKSB7XG4gICAgLy8gSWYgYW4gdXBwZXJCb3VuZCBoYXMgbm90IHlldCBiZWVuIGRldGVybWluZWQgKGR1ZSB0byB0aGUgY29tcG9uZW50IGJlaW5nIGhpZGRlblxuICAgIC8vIGR1cmluZyB0aGUgbW91bnQgZXZlbnQsIG9yIGR1cmluZyB0aGUgbGFzdCByZXNpemUpLCB0aGVuIGNhbGN1bGF0ZSBpdCBub3dcbiAgICBpZiAodGhpcy5zdGF0ZS51cHBlckJvdW5kID09PSAwKSB7XG4gICAgICB0aGlzLnJlc2l6ZSgpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICB0aGlzLmNsZWFyUGVuZGluZ1Jlc2l6ZVRpbWVvdXRzKCk7XG5cbiAgICBpZiAodGhpcy5yZXNpemVPYnNlcnZlcikge1xuICAgICAgdGhpcy5yZXNpemVPYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5vbkVuZCA9IGZ1bmN0aW9uIG9uRW5kKGV2ZW50TWFwKSB7XG4gICAgaWYgKGV2ZW50TWFwKSB7XG4gICAgICByZW1vdmVIYW5kbGVycyhldmVudE1hcCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaGFzTW92ZWQpIHtcbiAgICAgIHRoaXMuZmlyZUNoYW5nZUV2ZW50KCdvbkFmdGVyQ2hhbmdlJyk7XG4gICAgfSAvLyBBbGxvdyBjb250cm9sbGVkIHVwZGF0ZXMgdG8gY29udGludWVcblxuXG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBwZW5kaW5nOiBmYWxzZVxuICAgIH0pO1xuICAgIHRoaXMuaGFzTW92ZWQgPSBmYWxzZTtcbiAgfTtcblxuICBfcHJvdG8uZ2V0VmFsdWUgPSBmdW5jdGlvbiBnZXRWYWx1ZSgpIHtcbiAgICByZXR1cm4gcHJlcGFyZU91dFZhbHVlKHRoaXMuc3RhdGUudmFsdWUpO1xuICB9O1xuXG4gIF9wcm90by5nZXRDbG9zZXN0SW5kZXggPSBmdW5jdGlvbiBnZXRDbG9zZXN0SW5kZXgocGl4ZWxPZmZzZXQpIHtcbiAgICBsZXQgbWluRGlzdCA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgbGV0IGNsb3Nlc3RJbmRleCA9IC0xO1xuICAgIGNvbnN0IHtcbiAgICAgIHZhbHVlXG4gICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3QgbCA9IHZhbHVlLmxlbmd0aDtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbDsgaSArPSAxKSB7XG4gICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLmNhbGNPZmZzZXQodmFsdWVbaV0pO1xuICAgICAgY29uc3QgZGlzdCA9IE1hdGguYWJzKHBpeGVsT2Zmc2V0IC0gb2Zmc2V0KTtcblxuICAgICAgaWYgKGRpc3QgPCBtaW5EaXN0KSB7XG4gICAgICAgIG1pbkRpc3QgPSBkaXN0O1xuICAgICAgICBjbG9zZXN0SW5kZXggPSBpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjbG9zZXN0SW5kZXg7XG4gIH07XG5cbiAgX3Byb3RvLmdldE1vdXNlUG9zaXRpb24gPSBmdW5jdGlvbiBnZXRNb3VzZVBvc2l0aW9uKGUpIHtcbiAgICByZXR1cm4gW2VbXCJwYWdlXCIgKyB0aGlzLmF4aXNLZXkoKV0sIGVbXCJwYWdlXCIgKyB0aGlzLm9ydGhvZ29uYWxBeGlzS2V5KCldXTtcbiAgfTtcblxuICBfcHJvdG8uZ2V0VG91Y2hQb3NpdGlvbiA9IGZ1bmN0aW9uIGdldFRvdWNoUG9zaXRpb24oZSkge1xuICAgIGNvbnN0IHRvdWNoID0gZS50b3VjaGVzWzBdO1xuICAgIHJldHVybiBbdG91Y2hbXCJwYWdlXCIgKyB0aGlzLmF4aXNLZXkoKV0sIHRvdWNoW1wicGFnZVwiICsgdGhpcy5vcnRob2dvbmFsQXhpc0tleSgpXV07XG4gIH07XG5cbiAgX3Byb3RvLmdldEtleURvd25FdmVudE1hcCA9IGZ1bmN0aW9uIGdldEtleURvd25FdmVudE1hcCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAga2V5ZG93bjogdGhpcy5vbktleURvd24sXG4gICAgICBrZXl1cDogdGhpcy5vbktleVVwLFxuICAgICAgZm9jdXNvdXQ6IHRoaXMub25CbHVyXG4gICAgfTtcbiAgfTtcblxuICBfcHJvdG8uZ2V0TW91c2VFdmVudE1hcCA9IGZ1bmN0aW9uIGdldE1vdXNlRXZlbnRNYXAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1vdXNlbW92ZTogdGhpcy5vbk1vdXNlTW92ZSxcbiAgICAgIG1vdXNldXA6IHRoaXMub25Nb3VzZVVwXG4gICAgfTtcbiAgfTtcblxuICBfcHJvdG8uZ2V0VG91Y2hFdmVudE1hcCA9IGZ1bmN0aW9uIGdldFRvdWNoRXZlbnRNYXAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRvdWNobW92ZTogdGhpcy5vblRvdWNoTW92ZSxcbiAgICAgIHRvdWNoZW5kOiB0aGlzLm9uVG91Y2hFbmRcbiAgICB9O1xuICB9O1xuXG4gIF9wcm90by5nZXRWYWx1ZUZyb21Qb3NpdGlvbiA9IGZ1bmN0aW9uIGdldFZhbHVlRnJvbVBvc2l0aW9uKHBvc2l0aW9uKSB7XG4gICAgY29uc3QgZGlmZlZhbHVlID0gcG9zaXRpb24gLyAodGhpcy5zdGF0ZS5zbGlkZXJMZW5ndGggLSB0aGlzLnN0YXRlLnRodW1iU2l6ZSkgKiAodGhpcy5wcm9wcy5tYXggLSB0aGlzLnByb3BzLm1pbik7XG4gICAgcmV0dXJuIHRyaW1BbGlnblZhbHVlKHRoaXMuc3RhdGUuc3RhcnRWYWx1ZSArIGRpZmZWYWx1ZSwgdGhpcy5wcm9wcyk7XG4gIH07XG5cbiAgX3Byb3RvLmdldERpZmZQb3NpdGlvbiA9IGZ1bmN0aW9uIGdldERpZmZQb3NpdGlvbihwb3NpdGlvbikge1xuICAgIGxldCBkaWZmUG9zaXRpb24gPSBwb3NpdGlvbiAtIHRoaXMuc3RhdGUuc3RhcnRQb3NpdGlvbjtcblxuICAgIGlmICh0aGlzLnByb3BzLmludmVydCkge1xuICAgICAgZGlmZlBvc2l0aW9uICo9IC0xO1xuICAgIH1cblxuICAgIHJldHVybiBkaWZmUG9zaXRpb247XG4gIH0gLy8gY3JlYXRlIHRoZSBga2V5ZG93bmAgaGFuZGxlciBmb3IgdGhlIGktdGggdGh1bWJcbiAgO1xuXG4gIF9wcm90by5yZXNpemUgPSBmdW5jdGlvbiByZXNpemUoKSB7XG4gICAgY29uc3Qge1xuICAgICAgc2xpZGVyLFxuICAgICAgdGh1bWIwOiB0aHVtYlxuICAgIH0gPSB0aGlzO1xuXG4gICAgaWYgKCFzbGlkZXIgfHwgIXRodW1iKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgc2l6ZUtleSA9IHRoaXMuc2l6ZUtleSgpOyAvLyBGb3IgdGhlIHNsaWRlciBzaXplLCB3ZSB3YW50IHRvIHVzZSB0aGUgY2xpZW50IHdpZHRoL2hlaWdodCwgZXhjbHVkaW5nIGFueSBib3JkZXJzXG5cbiAgICBjb25zdCBzbGlkZXJSZWN0ID0gc2xpZGVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IHNsaWRlclNpemUgPSBzbGlkZXJbc2l6ZUtleV07XG4gICAgY29uc3Qgc2xpZGVyTWF4ID0gc2xpZGVyUmVjdFt0aGlzLnBvc01heEtleSgpXTtcbiAgICBjb25zdCBzbGlkZXJNaW4gPSBzbGlkZXJSZWN0W3RoaXMucG9zTWluS2V5KCldOyAvLyBGb3IgdGhlIHRodW1iIHNpemUsIHdlIHdhbnQgdG8gdXNlIHRoZSBvdXRlciB3aWR0aC9oZWlnaHQsIGluY2x1ZGluZyBhbnkgYm9yZGVyc1xuXG4gICAgY29uc3QgdGh1bWJSZWN0ID0gdGh1bWIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3QgdGh1bWJTaXplID0gdGh1bWJSZWN0W3NpemVLZXkucmVwbGFjZSgnY2xpZW50JywgJycpLnRvTG93ZXJDYXNlKCldO1xuICAgIGNvbnN0IHVwcGVyQm91bmQgPSBzbGlkZXJTaXplIC0gdGh1bWJTaXplO1xuICAgIGNvbnN0IHNsaWRlckxlbmd0aCA9IE1hdGguYWJzKHNsaWRlck1heCAtIHNsaWRlck1pbik7XG5cbiAgICBpZiAodGhpcy5zdGF0ZS51cHBlckJvdW5kICE9PSB1cHBlckJvdW5kIHx8IHRoaXMuc3RhdGUuc2xpZGVyTGVuZ3RoICE9PSBzbGlkZXJMZW5ndGggfHwgdGhpcy5zdGF0ZS50aHVtYlNpemUgIT09IHRodW1iU2l6ZSkge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIHVwcGVyQm91bmQsXG4gICAgICAgIHNsaWRlckxlbmd0aCxcbiAgICAgICAgdGh1bWJTaXplXG4gICAgICB9KTtcbiAgICB9XG4gIH0gLy8gY2FsY3VsYXRlcyB0aGUgb2Zmc2V0IG9mIGEgdGh1bWIgaW4gcGl4ZWxzIGJhc2VkIG9uIGl0cyB2YWx1ZS5cbiAgO1xuXG4gIF9wcm90by5jYWxjT2Zmc2V0ID0gZnVuY3Rpb24gY2FsY09mZnNldCh2YWx1ZSkge1xuICAgIGNvbnN0IHJhbmdlID0gdGhpcy5wcm9wcy5tYXggLSB0aGlzLnByb3BzLm1pbjtcblxuICAgIGlmIChyYW5nZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgY29uc3QgcmF0aW8gPSAodmFsdWUgLSB0aGlzLnByb3BzLm1pbikgLyByYW5nZTtcbiAgICByZXR1cm4gcmF0aW8gKiB0aGlzLnN0YXRlLnVwcGVyQm91bmQ7XG4gIH0gLy8gY2FsY3VsYXRlcyB0aGUgdmFsdWUgY29ycmVzcG9uZGluZyB0byBhIGdpdmVuIHBpeGVsIG9mZnNldCwgaS5lLiB0aGUgaW52ZXJzZSBvZiBgY2FsY09mZnNldGAuXG4gIDtcblxuICBfcHJvdG8uY2FsY1ZhbHVlID0gZnVuY3Rpb24gY2FsY1ZhbHVlKG9mZnNldCkge1xuICAgIGNvbnN0IHJhdGlvID0gb2Zmc2V0IC8gdGhpcy5zdGF0ZS51cHBlckJvdW5kO1xuICAgIHJldHVybiByYXRpbyAqICh0aGlzLnByb3BzLm1heCAtIHRoaXMucHJvcHMubWluKSArIHRoaXMucHJvcHMubWluO1xuICB9O1xuXG4gIF9wcm90by5jYWxjT2Zmc2V0RnJvbVBvc2l0aW9uID0gZnVuY3Rpb24gY2FsY09mZnNldEZyb21Qb3NpdGlvbihwb3NpdGlvbikge1xuICAgIGNvbnN0IHtcbiAgICAgIHNsaWRlclxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHNsaWRlclJlY3QgPSBzbGlkZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3Qgc2xpZGVyTWF4ID0gc2xpZGVyUmVjdFt0aGlzLnBvc01heEtleSgpXTtcbiAgICBjb25zdCBzbGlkZXJNaW4gPSBzbGlkZXJSZWN0W3RoaXMucG9zTWluS2V5KCldOyAvLyBUaGUgYHBvc2l0aW9uYCB2YWx1ZSBwYXNzZWQgaW4gaXMgdGhlIG1vdXNlIHBvc2l0aW9uIGJhc2VkIG9uIHRoZSB3aW5kb3cgaGVpZ2h0LlxuICAgIC8vIFRoZSBzbGlkZXIgYm91bmRpbmcgcmVjdCBpcyBiYXNlZCBvbiB0aGUgdmlld3BvcnQsIHNvIHdlIG11c3QgYWRkIHRoZSB3aW5kb3cgc2Nyb2xsXG4gICAgLy8gb2Zmc2V0IHRvIG5vcm1hbGl6ZSB0aGUgdmFsdWVzLlxuXG4gICAgY29uc3Qgd2luZG93T2Zmc2V0ID0gd2luZG93W1wicGFnZVwiICsgdGhpcy5heGlzS2V5KCkgKyBcIk9mZnNldFwiXTtcbiAgICBjb25zdCBzbGlkZXJTdGFydCA9IHdpbmRvd09mZnNldCArICh0aGlzLnByb3BzLmludmVydCA/IHNsaWRlck1heCA6IHNsaWRlck1pbik7XG4gICAgbGV0IHBpeGVsT2Zmc2V0ID0gcG9zaXRpb24gLSBzbGlkZXJTdGFydDtcblxuICAgIGlmICh0aGlzLnByb3BzLmludmVydCkge1xuICAgICAgcGl4ZWxPZmZzZXQgPSB0aGlzLnN0YXRlLnNsaWRlckxlbmd0aCAtIHBpeGVsT2Zmc2V0O1xuICAgIH1cblxuICAgIHBpeGVsT2Zmc2V0IC09IHRoaXMuc3RhdGUudGh1bWJTaXplIC8gMjtcbiAgICByZXR1cm4gcGl4ZWxPZmZzZXQ7XG4gIH0gLy8gU25hcHMgdGhlIG5lYXJlc3QgdGh1bWIgdG8gdGhlIHZhbHVlIGNvcnJlc3BvbmRpbmcgdG8gYHBvc2l0aW9uYFxuICAvLyBhbmQgY2FsbHMgYGNhbGxiYWNrYCB3aXRoIHRoYXQgdGh1bWIncyBpbmRleC5cbiAgO1xuXG4gIF9wcm90by5mb3JjZVZhbHVlRnJvbVBvc2l0aW9uID0gZnVuY3Rpb24gZm9yY2VWYWx1ZUZyb21Qb3NpdGlvbihwb3NpdGlvbiwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBwaXhlbE9mZnNldCA9IHRoaXMuY2FsY09mZnNldEZyb21Qb3NpdGlvbihwb3NpdGlvbik7XG4gICAgY29uc3QgY2xvc2VzdEluZGV4ID0gdGhpcy5nZXRDbG9zZXN0SW5kZXgocGl4ZWxPZmZzZXQpO1xuICAgIGNvbnN0IG5leHRWYWx1ZSA9IHRyaW1BbGlnblZhbHVlKHRoaXMuY2FsY1ZhbHVlKHBpeGVsT2Zmc2V0KSwgdGhpcy5wcm9wcyk7IC8vIENsb25lIHRoaXMuc3RhdGUudmFsdWUgc2luY2Ugd2UnbGwgbW9kaWZ5IGl0IHRlbXBvcmFyaWx5XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHppbGxvdy9yZWFjdC9uby1hY2Nlc3Mtc3RhdGUtaW4tc2V0c3RhdGVcblxuICAgIGNvbnN0IHZhbHVlID0gdGhpcy5zdGF0ZS52YWx1ZS5zbGljZSgpO1xuICAgIHZhbHVlW2Nsb3Nlc3RJbmRleF0gPSBuZXh0VmFsdWU7IC8vIFByZXZlbnRzIHRoZSBzbGlkZXIgZnJvbSBzaHJpbmtpbmcgYmVsb3cgYHByb3BzLm1pbkRpc3RhbmNlYFxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGggLSAxOyBpICs9IDEpIHtcbiAgICAgIGlmICh2YWx1ZVtpICsgMV0gLSB2YWx1ZVtpXSA8IHRoaXMucHJvcHMubWluRGlzdGFuY2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuZmlyZUNoYW5nZUV2ZW50KCdvbkJlZm9yZUNoYW5nZScpO1xuICAgIHRoaXMuaGFzTW92ZWQgPSB0cnVlO1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgdmFsdWVcbiAgICB9LCAoKSA9PiB7XG4gICAgICBjYWxsYmFjayhjbG9zZXN0SW5kZXgpO1xuICAgICAgdGhpcy5maXJlQ2hhbmdlRXZlbnQoJ29uQ2hhbmdlJyk7XG4gICAgfSk7XG4gIH0gLy8gY2xlYXIgYWxsIHBlbmRpbmcgdGltZW91dHMgdG8gYXZvaWQgZXJyb3IgbWVzc2FnZXMgYWZ0ZXIgdW5tb3VudGluZ1xuICA7XG5cbiAgX3Byb3RvLmNsZWFyUGVuZGluZ1Jlc2l6ZVRpbWVvdXRzID0gZnVuY3Rpb24gY2xlYXJQZW5kaW5nUmVzaXplVGltZW91dHMoKSB7XG4gICAgZG8ge1xuICAgICAgY29uc3QgbmV4dFRpbWVvdXQgPSB0aGlzLnBlbmRpbmdSZXNpemVUaW1lb3V0cy5zaGlmdCgpO1xuICAgICAgY2xlYXJUaW1lb3V0KG5leHRUaW1lb3V0KTtcbiAgICB9IHdoaWxlICh0aGlzLnBlbmRpbmdSZXNpemVUaW1lb3V0cy5sZW5ndGgpO1xuICB9O1xuXG4gIF9wcm90by5zdGFydCA9IGZ1bmN0aW9uIHN0YXJ0KGksIHBvc2l0aW9uKSB7XG4gICAgY29uc3QgdGh1bWJSZWYgPSB0aGlzW1widGh1bWJcIiArIGldO1xuXG4gICAgaWYgKHRodW1iUmVmKSB7XG4gICAgICB0aHVtYlJlZi5mb2N1cygpO1xuICAgIH1cblxuICAgIGNvbnN0IHtcbiAgICAgIHpJbmRpY2VzXG4gICAgfSA9IHRoaXMuc3RhdGU7IC8vIHJlbW92ZSB3aGVyZXZlciB0aGUgZWxlbWVudCBpc1xuXG4gICAgekluZGljZXMuc3BsaWNlKHpJbmRpY2VzLmluZGV4T2YoaSksIDEpOyAvLyBhZGQgdG8gZW5kXG5cbiAgICB6SW5kaWNlcy5wdXNoKGkpO1xuICAgIHRoaXMuc2V0U3RhdGUocHJldlN0YXRlID0+ICh7XG4gICAgICBzdGFydFZhbHVlOiBwcmV2U3RhdGUudmFsdWVbaV0sXG4gICAgICBzdGFydFBvc2l0aW9uOiBwb3NpdGlvbiAhPT0gdW5kZWZpbmVkID8gcG9zaXRpb24gOiBwcmV2U3RhdGUuc3RhcnRQb3NpdGlvbixcbiAgICAgIGluZGV4OiBpLFxuICAgICAgekluZGljZXNcbiAgICB9KSk7XG4gIH07XG5cbiAgX3Byb3RvLm1vdmVVcEJ5U3RlcCA9IGZ1bmN0aW9uIG1vdmVVcEJ5U3RlcChzdGVwKSB7XG4gICAgaWYgKHN0ZXAgPT09IHZvaWQgMCkge1xuICAgICAgc3RlcCA9IHRoaXMucHJvcHMuc3RlcDtcbiAgICB9XG5cbiAgICBjb25zdCBvbGRWYWx1ZSA9IHRoaXMuc3RhdGUudmFsdWVbdGhpcy5zdGF0ZS5pbmRleF07IC8vIGlmIHRoZSBzbGlkZXIgaXMgaW52ZXJ0ZWQgYW5kIGhvcml6b250YWwgd2Ugd2FudCB0byBob25vciB0aGUgaW52ZXJ0ZWQgdmFsdWVcblxuICAgIGNvbnN0IG5ld1ZhbHVlID0gdGhpcy5wcm9wcy5pbnZlcnQgJiYgdGhpcy5wcm9wcy5vcmllbnRhdGlvbiA9PT0gJ2hvcml6b250YWwnID8gb2xkVmFsdWUgLSBzdGVwIDogb2xkVmFsdWUgKyBzdGVwO1xuICAgIGNvbnN0IHRyaW1BbGlnbiA9IHRyaW1BbGlnblZhbHVlKG5ld1ZhbHVlLCB0aGlzLnByb3BzKTtcbiAgICB0aGlzLm1vdmUoTWF0aC5taW4odHJpbUFsaWduLCB0aGlzLnByb3BzLm1heCkpO1xuICB9O1xuXG4gIF9wcm90by5tb3ZlRG93bkJ5U3RlcCA9IGZ1bmN0aW9uIG1vdmVEb3duQnlTdGVwKHN0ZXApIHtcbiAgICBpZiAoc3RlcCA9PT0gdm9pZCAwKSB7XG4gICAgICBzdGVwID0gdGhpcy5wcm9wcy5zdGVwO1xuICAgIH1cblxuICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpcy5zdGF0ZS52YWx1ZVt0aGlzLnN0YXRlLmluZGV4XTsgLy8gaWYgdGhlIHNsaWRlciBpcyBpbnZlcnRlZCBhbmQgaG9yaXpvbnRhbCB3ZSB3YW50IHRvIGhvbm9yIHRoZSBpbnZlcnRlZCB2YWx1ZVxuXG4gICAgY29uc3QgbmV3VmFsdWUgPSB0aGlzLnByb3BzLmludmVydCAmJiB0aGlzLnByb3BzLm9yaWVudGF0aW9uID09PSAnaG9yaXpvbnRhbCcgPyBvbGRWYWx1ZSArIHN0ZXAgOiBvbGRWYWx1ZSAtIHN0ZXA7XG4gICAgY29uc3QgdHJpbUFsaWduID0gdHJpbUFsaWduVmFsdWUobmV3VmFsdWUsIHRoaXMucHJvcHMpO1xuICAgIHRoaXMubW92ZShNYXRoLm1heCh0cmltQWxpZ24sIHRoaXMucHJvcHMubWluKSk7XG4gIH07XG5cbiAgX3Byb3RvLm1vdmUgPSBmdW5jdGlvbiBtb3ZlKG5ld1ZhbHVlKSB7XG4gICAgLy8gQ2xvbmUgdGhpcy5zdGF0ZS52YWx1ZSBzaW5jZSB3ZSdsbCBtb2RpZnkgaXQgdGVtcG9yYXJpbHlcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgemlsbG93L3JlYWN0L25vLWFjY2Vzcy1zdGF0ZS1pbi1zZXRzdGF0ZVxuICAgIGNvbnN0IHZhbHVlID0gdGhpcy5zdGF0ZS52YWx1ZS5zbGljZSgpO1xuICAgIGNvbnN0IHtcbiAgICAgIGluZGV4XG4gICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3Qge1xuICAgICAgbGVuZ3RoXG4gICAgfSA9IHZhbHVlOyAvLyBTaG9ydCBjaXJjdWl0IGlmIHRoZSB2YWx1ZSBpcyBub3QgY2hhbmdpbmdcblxuICAgIGNvbnN0IG9sZFZhbHVlID0gdmFsdWVbaW5kZXhdO1xuXG4gICAgaWYgKG5ld1ZhbHVlID09PSBvbGRWYWx1ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gVHJpZ2dlciBvbmx5IGJlZm9yZSB0aGUgZmlyc3QgbW92ZW1lbnRcblxuXG4gICAgaWYgKCF0aGlzLmhhc01vdmVkKSB7XG4gICAgICB0aGlzLmZpcmVDaGFuZ2VFdmVudCgnb25CZWZvcmVDaGFuZ2UnKTtcbiAgICB9XG5cbiAgICB0aGlzLmhhc01vdmVkID0gdHJ1ZTsgLy8gaWYgXCJwZWFybGluZ1wiICg9IHRodW1icyBwdXNoaW5nIGVhY2ggb3RoZXIpIGlzIGRpc2FibGVkLFxuICAgIC8vIHByZXZlbnQgdGhlIHRodW1iIGZyb20gZ2V0dGluZyBjbG9zZXIgdGhhbiBgbWluRGlzdGFuY2VgIHRvIHRoZSBwcmV2aW91cyBvciBuZXh0IHRodW1iLlxuXG4gICAgY29uc3Qge1xuICAgICAgcGVhcmxpbmcsXG4gICAgICBtYXgsXG4gICAgICBtaW4sXG4gICAgICBtaW5EaXN0YW5jZVxuICAgIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgaWYgKCFwZWFybGluZykge1xuICAgICAgaWYgKGluZGV4ID4gMCkge1xuICAgICAgICBjb25zdCB2YWx1ZUJlZm9yZSA9IHZhbHVlW2luZGV4IC0gMV07XG5cbiAgICAgICAgaWYgKG5ld1ZhbHVlIDwgdmFsdWVCZWZvcmUgKyBtaW5EaXN0YW5jZSkge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgIG5ld1ZhbHVlID0gdmFsdWVCZWZvcmUgKyBtaW5EaXN0YW5jZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaW5kZXggPCBsZW5ndGggLSAxKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlQWZ0ZXIgPSB2YWx1ZVtpbmRleCArIDFdO1xuXG4gICAgICAgIGlmIChuZXdWYWx1ZSA+IHZhbHVlQWZ0ZXIgLSBtaW5EaXN0YW5jZSkge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgIG5ld1ZhbHVlID0gdmFsdWVBZnRlciAtIG1pbkRpc3RhbmNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFsdWVbaW5kZXhdID0gbmV3VmFsdWU7IC8vIGlmIFwicGVhcmxpbmdcIiBpcyBlbmFibGVkLCBsZXQgdGhlIGN1cnJlbnQgdGh1bWIgcHVzaCB0aGUgcHJlLSBhbmQgc3VjY2VlZGluZyB0aHVtYnMuXG5cbiAgICBpZiAocGVhcmxpbmcgJiYgbGVuZ3RoID4gMSkge1xuICAgICAgaWYgKG5ld1ZhbHVlID4gb2xkVmFsdWUpIHtcbiAgICAgICAgdGhpcy5wdXNoU3VjY2VlZGluZyh2YWx1ZSwgbWluRGlzdGFuY2UsIGluZGV4KTtcbiAgICAgICAgdHJpbVN1Y2NlZWRpbmcobGVuZ3RoLCB2YWx1ZSwgbWluRGlzdGFuY2UsIG1heCk7XG4gICAgICB9IGVsc2UgaWYgKG5ld1ZhbHVlIDwgb2xkVmFsdWUpIHtcbiAgICAgICAgdGhpcy5wdXNoUHJlY2VkaW5nKHZhbHVlLCBtaW5EaXN0YW5jZSwgaW5kZXgpO1xuICAgICAgICB0cmltUHJlY2VkaW5nKGxlbmd0aCwgdmFsdWUsIG1pbkRpc3RhbmNlLCBtaW4pO1xuICAgICAgfVxuICAgIH0gLy8gTm9ybWFsbHkgeW91IHdvdWxkIHVzZSBgc2hvdWxkQ29tcG9uZW50VXBkYXRlYCxcbiAgICAvLyBidXQgc2luY2UgdGhlIHNsaWRlciBpcyBhIGxvdy1sZXZlbCBjb21wb25lbnQsXG4gICAgLy8gdGhlIGV4dHJhIGNvbXBsZXhpdHkgbWlnaHQgYmUgd29ydGggdGhlIGV4dHJhIHBlcmZvcm1hbmNlLlxuXG5cbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIHZhbHVlXG4gICAgfSwgdGhpcy5maXJlQ2hhbmdlRXZlbnQuYmluZCh0aGlzLCAnb25DaGFuZ2UnKSk7XG4gIH07XG5cbiAgX3Byb3RvLnB1c2hTdWNjZWVkaW5nID0gZnVuY3Rpb24gcHVzaFN1Y2NlZWRpbmcodmFsdWUsIG1pbkRpc3RhbmNlLCBpbmRleCkge1xuICAgIGxldCBpO1xuICAgIGxldCBwYWRkaW5nO1xuXG4gICAgZm9yIChpID0gaW5kZXgsIHBhZGRpbmcgPSB2YWx1ZVtpXSArIG1pbkRpc3RhbmNlOyB2YWx1ZVtpICsgMV0gIT09IG51bGwgJiYgcGFkZGluZyA+IHZhbHVlW2kgKyAxXTsgaSArPSAxLCBwYWRkaW5nID0gdmFsdWVbaV0gKyBtaW5EaXN0YW5jZSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICB2YWx1ZVtpICsgMV0gPSBhbGlnblZhbHVlKHBhZGRpbmcsIHRoaXMucHJvcHMpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ucHVzaFByZWNlZGluZyA9IGZ1bmN0aW9uIHB1c2hQcmVjZWRpbmcodmFsdWUsIG1pbkRpc3RhbmNlLCBpbmRleCkge1xuICAgIGZvciAobGV0IGkgPSBpbmRleCwgcGFkZGluZyA9IHZhbHVlW2ldIC0gbWluRGlzdGFuY2U7IHZhbHVlW2kgLSAxXSAhPT0gbnVsbCAmJiBwYWRkaW5nIDwgdmFsdWVbaSAtIDFdOyBpIC09IDEsIHBhZGRpbmcgPSB2YWx1ZVtpXSAtIG1pbkRpc3RhbmNlKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgIHZhbHVlW2kgLSAxXSA9IGFsaWduVmFsdWUocGFkZGluZywgdGhpcy5wcm9wcyk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5heGlzS2V5ID0gZnVuY3Rpb24gYXhpc0tleSgpIHtcbiAgICBpZiAodGhpcy5wcm9wcy5vcmllbnRhdGlvbiA9PT0gJ3ZlcnRpY2FsJykge1xuICAgICAgcmV0dXJuICdZJztcbiAgICB9IC8vIERlZmF1bHRzIHRvICdob3Jpem9udGFsJztcblxuXG4gICAgcmV0dXJuICdYJztcbiAgfTtcblxuICBfcHJvdG8ub3J0aG9nb25hbEF4aXNLZXkgPSBmdW5jdGlvbiBvcnRob2dvbmFsQXhpc0tleSgpIHtcbiAgICBpZiAodGhpcy5wcm9wcy5vcmllbnRhdGlvbiA9PT0gJ3ZlcnRpY2FsJykge1xuICAgICAgcmV0dXJuICdYJztcbiAgICB9IC8vIERlZmF1bHRzIHRvICdob3Jpem9udGFsJ1xuXG5cbiAgICByZXR1cm4gJ1knO1xuICB9O1xuXG4gIF9wcm90by5wb3NNaW5LZXkgPSBmdW5jdGlvbiBwb3NNaW5LZXkoKSB7XG4gICAgaWYgKHRoaXMucHJvcHMub3JpZW50YXRpb24gPT09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgIHJldHVybiB0aGlzLnByb3BzLmludmVydCA/ICdib3R0b20nIDogJ3RvcCc7XG4gICAgfSAvLyBEZWZhdWx0cyB0byAnaG9yaXpvbnRhbCdcblxuXG4gICAgcmV0dXJuIHRoaXMucHJvcHMuaW52ZXJ0ID8gJ3JpZ2h0JyA6ICdsZWZ0JztcbiAgfTtcblxuICBfcHJvdG8ucG9zTWF4S2V5ID0gZnVuY3Rpb24gcG9zTWF4S2V5KCkge1xuICAgIGlmICh0aGlzLnByb3BzLm9yaWVudGF0aW9uID09PSAndmVydGljYWwnKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcm9wcy5pbnZlcnQgPyAndG9wJyA6ICdib3R0b20nO1xuICAgIH0gLy8gRGVmYXVsdHMgdG8gJ2hvcml6b250YWwnXG5cblxuICAgIHJldHVybiB0aGlzLnByb3BzLmludmVydCA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gIH07XG5cbiAgX3Byb3RvLnNpemVLZXkgPSBmdW5jdGlvbiBzaXplS2V5KCkge1xuICAgIGlmICh0aGlzLnByb3BzLm9yaWVudGF0aW9uID09PSAndmVydGljYWwnKSB7XG4gICAgICByZXR1cm4gJ2NsaWVudEhlaWdodCc7XG4gICAgfSAvLyBEZWZhdWx0cyB0byAnaG9yaXpvbnRhbCdcblxuXG4gICAgcmV0dXJuICdjbGllbnRXaWR0aCc7XG4gIH07XG5cbiAgX3Byb3RvLmZpcmVDaGFuZ2VFdmVudCA9IGZ1bmN0aW9uIGZpcmVDaGFuZ2VFdmVudChldmVudCkge1xuICAgIGlmICh0aGlzLnByb3BzW2V2ZW50XSkge1xuICAgICAgdGhpcy5wcm9wc1tldmVudF0ocHJlcGFyZU91dFZhbHVlKHRoaXMuc3RhdGUudmFsdWUpLCB0aGlzLnN0YXRlLmluZGV4KTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmJ1aWxkVGh1bWJTdHlsZSA9IGZ1bmN0aW9uIGJ1aWxkVGh1bWJTdHlsZShvZmZzZXQsIGkpIHtcbiAgICBjb25zdCBzdHlsZSA9IHtcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgdG91Y2hBY3Rpb246ICdub25lJyxcbiAgICAgIHdpbGxDaGFuZ2U6IHRoaXMuc3RhdGUuaW5kZXggPj0gMCA/IHRoaXMucG9zTWluS2V5KCkgOiB1bmRlZmluZWQsXG4gICAgICB6SW5kZXg6IHRoaXMuc3RhdGUuekluZGljZXMuaW5kZXhPZihpKSArIDFcbiAgICB9O1xuICAgIHN0eWxlW3RoaXMucG9zTWluS2V5KCldID0gb2Zmc2V0ICsgXCJweFwiO1xuICAgIHJldHVybiBzdHlsZTtcbiAgfTtcblxuICBfcHJvdG8uYnVpbGRUcmFja1N0eWxlID0gZnVuY3Rpb24gYnVpbGRUcmFja1N0eWxlKG1pbiwgbWF4KSB7XG4gICAgY29uc3Qgb2JqID0ge1xuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICB3aWxsQ2hhbmdlOiB0aGlzLnN0YXRlLmluZGV4ID49IDAgPyB0aGlzLnBvc01pbktleSgpICsgXCIsXCIgKyB0aGlzLnBvc01heEtleSgpIDogdW5kZWZpbmVkXG4gICAgfTtcbiAgICBvYmpbdGhpcy5wb3NNaW5LZXkoKV0gPSBtaW47XG4gICAgb2JqW3RoaXMucG9zTWF4S2V5KCldID0gbWF4O1xuICAgIHJldHVybiBvYmo7XG4gIH07XG5cbiAgX3Byb3RvLmJ1aWxkTWFya1N0eWxlID0gZnVuY3Rpb24gYnVpbGRNYXJrU3R5bGUob2Zmc2V0KSB7XG4gICAgdmFyIF9yZWY7XG5cbiAgICByZXR1cm4gX3JlZiA9IHtcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnXG4gICAgfSwgX3JlZlt0aGlzLnBvc01pbktleSgpXSA9IG9mZnNldCwgX3JlZjtcbiAgfTtcblxuICBfcHJvdG8ucmVuZGVyVGh1bWJzID0gZnVuY3Rpb24gcmVuZGVyVGh1bWJzKG9mZnNldCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGxlbmd0aFxuICAgIH0gPSBvZmZzZXQ7XG4gICAgY29uc3Qgc3R5bGVzID0gW107XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBzdHlsZXNbaV0gPSB0aGlzLmJ1aWxkVGh1bWJTdHlsZShvZmZzZXRbaV0sIGkpO1xuICAgIH1cblxuICAgIGNvbnN0IHJlcyA9IFtdO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgICAgcmVzW2ldID0gdGhpcy5yZW5kZXJUaHVtYihzdHlsZXNbaV0sIGkpO1xuICAgIH1cblxuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgX3Byb3RvLnJlbmRlclRyYWNrcyA9IGZ1bmN0aW9uIHJlbmRlclRyYWNrcyhvZmZzZXQpIHtcbiAgICBjb25zdCB0cmFja3MgPSBbXTtcbiAgICBjb25zdCBsYXN0SW5kZXggPSBvZmZzZXQubGVuZ3RoIC0gMTtcbiAgICB0cmFja3MucHVzaCh0aGlzLnJlbmRlclRyYWNrKDAsIDAsIG9mZnNldFswXSkpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsYXN0SW5kZXg7IGkgKz0gMSkge1xuICAgICAgdHJhY2tzLnB1c2godGhpcy5yZW5kZXJUcmFjayhpICsgMSwgb2Zmc2V0W2ldLCBvZmZzZXRbaSArIDFdKSk7XG4gICAgfVxuXG4gICAgdHJhY2tzLnB1c2godGhpcy5yZW5kZXJUcmFjayhsYXN0SW5kZXggKyAxLCBvZmZzZXRbbGFzdEluZGV4XSwgdGhpcy5zdGF0ZS51cHBlckJvdW5kKSk7XG4gICAgcmV0dXJuIHRyYWNrcztcbiAgfTtcblxuICBfcHJvdG8ucmVuZGVyTWFya3MgPSBmdW5jdGlvbiByZW5kZXJNYXJrcygpIHtcbiAgICBsZXQge1xuICAgICAgbWFya3NcbiAgICB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCByYW5nZSA9IHRoaXMucHJvcHMubWF4IC0gdGhpcy5wcm9wcy5taW4gKyAxO1xuXG4gICAgaWYgKHR5cGVvZiBtYXJrcyA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICBtYXJrcyA9IEFycmF5LmZyb20oe1xuICAgICAgICBsZW5ndGg6IHJhbmdlXG4gICAgICB9KS5tYXAoKF8sIGtleSkgPT4ga2V5KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtYXJrcyA9PT0gJ251bWJlcicpIHtcbiAgICAgIG1hcmtzID0gQXJyYXkuZnJvbSh7XG4gICAgICAgIGxlbmd0aDogcmFuZ2VcbiAgICAgIH0pLm1hcCgoXywga2V5KSA9PiBrZXkpLmZpbHRlcihrZXkgPT4ga2V5ICUgbWFya3MgPT09IDApO1xuICAgIH1cblxuICAgIHJldHVybiBtYXJrcy5tYXAocGFyc2VGbG9hdCkuc29ydCgoYSwgYikgPT4gYSAtIGIpLm1hcChtYXJrID0+IHtcbiAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuY2FsY09mZnNldChtYXJrKTtcbiAgICAgIGNvbnN0IHByb3BzID0ge1xuICAgICAgICBrZXk6IG1hcmssXG4gICAgICAgIGNsYXNzTmFtZTogdGhpcy5wcm9wcy5tYXJrQ2xhc3NOYW1lLFxuICAgICAgICBzdHlsZTogdGhpcy5idWlsZE1hcmtTdHlsZShvZmZzZXQpXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHRoaXMucHJvcHMucmVuZGVyTWFyayhwcm9wcyk7XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICBjb25zdCBvZmZzZXQgPSBbXTtcbiAgICBjb25zdCB7XG4gICAgICB2YWx1ZVxuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IGwgPSB2YWx1ZS5sZW5ndGg7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGw7IGkgKz0gMSkge1xuICAgICAgb2Zmc2V0W2ldID0gdGhpcy5jYWxjT2Zmc2V0KHZhbHVlW2ldLCBpKTtcbiAgICB9XG5cbiAgICBjb25zdCB0cmFja3MgPSB0aGlzLnByb3BzLndpdGhUcmFja3MgPyB0aGlzLnJlbmRlclRyYWNrcyhvZmZzZXQpIDogbnVsbDtcbiAgICBjb25zdCB0aHVtYnMgPSB0aGlzLnJlbmRlclRodW1icyhvZmZzZXQpO1xuICAgIGNvbnN0IG1hcmtzID0gdGhpcy5wcm9wcy5tYXJrcyA/IHRoaXMucmVuZGVyTWFya3MoKSA6IG51bGw7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KCdkaXYnLCB7XG4gICAgICByZWY6IHIgPT4ge1xuICAgICAgICB0aGlzLnNsaWRlciA9IHI7XG4gICAgICAgIHRoaXMucmVzaXplRWxlbWVudFJlZi5jdXJyZW50ID0gcjtcbiAgICAgIH0sXG4gICAgICBzdHlsZToge1xuICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJ1xuICAgICAgfSxcbiAgICAgIGNsYXNzTmFtZTogdGhpcy5wcm9wcy5jbGFzc05hbWUgKyAodGhpcy5wcm9wcy5kaXNhYmxlZCA/ICcgZGlzYWJsZWQnIDogJycpLFxuICAgICAgb25Nb3VzZURvd246IHRoaXMub25TbGlkZXJNb3VzZURvd24sXG4gICAgICBvbkNsaWNrOiB0aGlzLm9uU2xpZGVyQ2xpY2tcbiAgICB9LCB0cmFja3MsIHRodW1icywgbWFya3MpO1xuICB9O1xuXG4gIHJldHVybiBSZWFjdFNsaWRlcjtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuUmVhY3RTbGlkZXIuZGlzcGxheU5hbWUgPSAnUmVhY3RTbGlkZXInO1xuUmVhY3RTbGlkZXIuZGVmYXVsdFByb3BzID0ge1xuICBtaW46IDAsXG4gIG1heDogMTAwLFxuICBzdGVwOiAxLFxuICBwYWdlRm46IHN0ZXAgPT4gc3RlcCAqIDEwLFxuICBtaW5EaXN0YW5jZTogMCxcbiAgZGVmYXVsdFZhbHVlOiAwLFxuICBvcmllbnRhdGlvbjogJ2hvcml6b250YWwnLFxuICBjbGFzc05hbWU6ICdzbGlkZXInLFxuICB0aHVtYkNsYXNzTmFtZTogJ3RodW1iJyxcbiAgdGh1bWJBY3RpdmVDbGFzc05hbWU6ICdhY3RpdmUnLFxuICB0cmFja0NsYXNzTmFtZTogJ3RyYWNrJyxcbiAgbWFya0NsYXNzTmFtZTogJ21hcmsnLFxuICB3aXRoVHJhY2tzOiB0cnVlLFxuICBwZWFybGluZzogZmFsc2UsXG4gIGRpc2FibGVkOiBmYWxzZSxcbiAgc25hcERyYWdEaXNhYmxlZDogZmFsc2UsXG4gIGludmVydDogZmFsc2UsXG4gIG1hcmtzOiBbXSxcbiAgcmVuZGVyVGh1bWI6IHByb3BzID0+IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIF9leHRlbmRzKHt9LCBwcm9wcywge1xuICAgIF9fc2VsZjogUmVhY3RTbGlkZXIsXG4gICAgX19zb3VyY2U6IHtcbiAgICAgIGZpbGVOYW1lOiBfanN4RmlsZU5hbWUsXG4gICAgICBsaW5lTnVtYmVyOiAzNTMsXG4gICAgICBjb2x1bW5OdW1iZXI6IDMxXG4gICAgfVxuICB9KSksXG4gIHJlbmRlclRyYWNrOiBwcm9wcyA9PiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgICBfX3NlbGY6IFJlYWN0U2xpZGVyLFxuICAgIF9fc291cmNlOiB7XG4gICAgICBmaWxlTmFtZTogX2pzeEZpbGVOYW1lLFxuICAgICAgbGluZU51bWJlcjogMzU0LFxuICAgICAgY29sdW1uTnVtYmVyOiAzMVxuICAgIH1cbiAgfSkpLFxuICByZW5kZXJNYXJrOiBwcm9wcyA9PiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgX19zZWxmOiBSZWFjdFNsaWRlcixcbiAgICBfX3NvdXJjZToge1xuICAgICAgZmlsZU5hbWU6IF9qc3hGaWxlTmFtZSxcbiAgICAgIGxpbmVOdW1iZXI6IDM1NSxcbiAgICAgIGNvbHVtbk51bWJlcjogMzBcbiAgICB9XG4gIH0pKVxufTtcblJlYWN0U2xpZGVyLnByb3BUeXBlcyA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHtcbiAgLyoqXG4gICAqIFRoZSBtaW5pbXVtIHZhbHVlIG9mIHRoZSBzbGlkZXIuXG4gICAqL1xuICBtaW46IFByb3BUeXBlcy5udW1iZXIsXG5cbiAgLyoqXG4gICAqIFRoZSBtYXhpbXVtIHZhbHVlIG9mIHRoZSBzbGlkZXIuXG4gICAqL1xuICBtYXg6IFByb3BUeXBlcy5udW1iZXIsXG5cbiAgLyoqXG4gICAqIFZhbHVlIHRvIGJlIGFkZGVkIG9yIHN1YnRyYWN0ZWQgb24gZWFjaCBzdGVwIHRoZSBzbGlkZXIgbWFrZXMuXG4gICAqIE11c3QgYmUgZ3JlYXRlciB0aGFuIHplcm8uXG4gICAqIGBtYXggLSBtaW5gIHNob3VsZCBiZSBldmVubHkgZGl2aXNpYmxlIGJ5IHRoZSBzdGVwIHZhbHVlLlxuICAgKi9cbiAgc3RlcDogUHJvcFR5cGVzLm51bWJlcixcblxuICAvKipcbiAgICogVGhlIHJlc3VsdCBvZiB0aGUgZnVuY3Rpb24gaXMgdGhlIHZhbHVlIHRvIGJlIGFkZGVkIG9yIHN1YnRyYWN0ZWRcbiAgICogd2hlbiB0aGUgYFBhZ2UgVXBgIG9yIGBQYWdlIERvd25gIGtleXMgYXJlIHByZXNzZWQuXG4gICAqXG4gICAqIFRoZSBjdXJyZW50IGBzdGVwYCB2YWx1ZSB3aWxsIGJlIHBhc3NlZCBhcyB0aGUgb25seSBhcmd1bWVudC5cbiAgICogQnkgZGVmYXVsdCwgcGFnaW5nIHdpbGwgbW9kaWZ5IGBzdGVwYCBieSBhIGZhY3RvciBvZiAxMC5cbiAgICovXG4gIHBhZ2VGbjogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIFRoZSBtaW5pbWFsIGRpc3RhbmNlIGJldHdlZW4gYW55IHBhaXIgb2YgdGh1bWJzLlxuICAgKiBNdXN0IGJlIHBvc2l0aXZlLCBidXQgemVybyBtZWFucyB0aGV5IGNhbiBzaXQgb24gdG9wIG9mIGVhY2ggb3RoZXIuXG4gICAqL1xuICBtaW5EaXN0YW5jZTogUHJvcFR5cGVzLm51bWJlcixcblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyB0aGUgaW5pdGlhbCBwb3NpdGlvbnMgb2YgdGhlIHRodW1icyBhbmQgdGhlIG51bWJlciBvZiB0aHVtYnMuXG4gICAqXG4gICAqIElmIGEgbnVtYmVyIGlzIHBhc3NlZCBhIHNsaWRlciB3aXRoIG9uZSB0aHVtYiB3aWxsIGJlIHJlbmRlcmVkLlxuICAgKiBJZiBhbiBhcnJheSBpcyBwYXNzZWQgZWFjaCB2YWx1ZSB3aWxsIGRldGVybWluZSB0aGUgcG9zaXRpb24gb2Ygb25lIHRodW1iLlxuICAgKiBUaGUgdmFsdWVzIGluIHRoZSBhcnJheSBtdXN0IGJlIHNvcnRlZC5cbiAgICovXG4gIGRlZmF1bHRWYWx1ZTogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm51bWJlciwgUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLm51bWJlcildKSxcblxuICAvKipcbiAgICogTGlrZSBgZGVmYXVsdFZhbHVlYCBidXQgZm9yXG4gICAqIFtjb250cm9sbGVkIGNvbXBvbmVudHNdKGh0dHA6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy9mb3Jtcy5odG1sI2NvbnRyb2xsZWQtY29tcG9uZW50cykuXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgemlsbG93L3JlYWN0L3JlcXVpcmUtZGVmYXVsdC1wcm9wc1xuICB2YWx1ZTogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm51bWJlciwgUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLm51bWJlcildKSxcblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBzbGlkZXIgbW92ZXMgaG9yaXpvbnRhbGx5IChmcm9tIGxlZnQgdG8gcmlnaHQpXG4gICAqIG9yIHZlcnRpY2FsbHkgKGZyb20gdG9wIHRvIGJvdHRvbSkuXG4gICAqL1xuICBvcmllbnRhdGlvbjogUHJvcFR5cGVzLm9uZU9mKFsnaG9yaXpvbnRhbCcsICd2ZXJ0aWNhbCddKSxcblxuICAvKipcbiAgICogVGhlIGNzcyBjbGFzcyBzZXQgb24gdGhlIHNsaWRlciBub2RlLlxuICAgKi9cbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuXG4gIC8qKlxuICAgKiBUaGUgY3NzIGNsYXNzIHNldCBvbiBlYWNoIHRodW1iIG5vZGUuXG4gICAqXG4gICAqIEluIGFkZGl0aW9uIGVhY2ggdGh1bWIgd2lsbCByZWNlaXZlIGEgbnVtYmVyZWQgY3NzIGNsYXNzIG9mIHRoZSBmb3JtXG4gICAqIGAke3RodW1iQ2xhc3NOYW1lfS0ke2l9YCwgZS5nLiBgdGh1bWItMGAsIGB0aHVtYi0xYCwgLi4uXG4gICAqL1xuICB0aHVtYkNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcblxuICAvKipcbiAgICogVGhlIGNzcyBjbGFzcyBzZXQgb24gdGhlIHRodW1iIHRoYXQgaXMgY3VycmVudGx5IGJlaW5nIG1vdmVkLlxuICAgKi9cbiAgdGh1bWJBY3RpdmVDbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCB0cmFja3MgYmV0d2VlbiB0aGUgdGh1bWJzIHdpbGwgYmUgcmVuZGVyZWQuXG4gICAqL1xuICB3aXRoVHJhY2tzOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogVGhlIGNzcyBjbGFzcyBzZXQgb24gdGhlIHRyYWNrcyBiZXR3ZWVuIHRoZSB0aHVtYnMuXG4gICAqIEluIGFkZGl0aW9uIHRyYWNrIGZyYWdtZW50IHdpbGwgcmVjZWl2ZSBhIG51bWJlcmVkIGNzcyBjbGFzcyBvZiB0aGUgZm9ybVxuICAgKiBgJHt0cmFja0NsYXNzTmFtZX0tJHtpfWAsIGUuZy4gYHRyYWNrLTBgLCBgdHJhY2stMWAsIC4uLlxuICAgKi9cbiAgdHJhY2tDbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCB0aGUgYWN0aXZlIHRodW1iIHdpbGwgcHVzaCBvdGhlciB0aHVtYnNcbiAgICogd2l0aGluIHRoZSBjb25zdHJhaW50cyBvZiBgbWluYCwgYG1heGAsIGBzdGVwYCBhbmQgYG1pbkRpc3RhbmNlYC5cbiAgICovXG4gIHBlYXJsaW5nOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogSWYgYHRydWVgIHRoZSB0aHVtYnMgY2FuJ3QgYmUgbW92ZWQuXG4gICAqL1xuICBkaXNhYmxlZDogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIERpc2FibGVzIHRodW1iIG1vdmUgd2hlbiBjbGlja2luZyB0aGUgc2xpZGVyIHRyYWNrXG4gICAqL1xuICBzbmFwRHJhZ0Rpc2FibGVkOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogSW52ZXJ0cyB0aGUgc2xpZGVyLlxuICAgKi9cbiAgaW52ZXJ0OiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogU2hvd3MgcGFzc2VkIG1hcmtzIG9uIHRoZSB0cmFjaywgaWYgdHJ1ZSBpdCBzaG93cyBhbGwgdGhlIG1hcmtzLFxuICAgKiBpZiBhbiBhcnJheSBvZiBudW1iZXJzIGl0IHNob3dzIGp1c3QgdGhlIHBhc3NlZCBtYXJrcywgaWYgYSBudW1iZXIgaXMgcGFzc2VkXG4gICAqIGl0IHNob3dzIGp1c3QgdGhlIG1hcmtzIGluIHRoYXQgc3RlcHM6IGxpa2UgcGFzc2luZyAzIHNob3dzIHRoZSBtYXJrcyAzLCA2LCA5XG4gICAqL1xuICBtYXJrczogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLm51bWJlciksIFByb3BUeXBlcy5ib29sLCBQcm9wVHlwZXMubnVtYmVyXSksXG5cbiAgLyoqXG4gICAqIFRoZSBjc3MgY2xhc3Mgc2V0IG9uIHRoZSBtYXJrcy5cbiAgICovXG4gIG1hcmtDbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGNhbGxlZCBiZWZvcmUgc3RhcnRpbmcgdG8gbW92ZSBhIHRodW1iLiBUaGUgY2FsbGJhY2sgd2lsbCBvbmx5IGJlIGNhbGxlZCBpZiB0aGVcbiAgICogYWN0aW9uIHdpbGwgcmVzdWx0IGluIGEgY2hhbmdlLiBUaGUgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgd2l0aCB0d28gYXJndW1lbnRzLCB0aGUgZmlyc3RcbiAgICogYmVpbmcgdGhlIGluaXRpYWwgdmFsdWUocykgdGhlIHNlY29uZCBiZWluZyB0aHVtYiBpbmRleC5cbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtbGVuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB6aWxsb3cvcmVhY3QvcmVxdWlyZS1kZWZhdWx0LXByb3BzLCB6aWxsb3cvcmVhY3Qvbm8tdW51c2VkLXByb3AtdHlwZXNcbiAgb25CZWZvcmVDaGFuZ2U6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBjYWxsZWQgb24gZXZlcnkgdmFsdWUgY2hhbmdlLlxuICAgKiBUaGUgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgd2l0aCB0d28gYXJndW1lbnRzLCB0aGUgZmlyc3QgYmVpbmcgdGhlIG5ldyB2YWx1ZShzKVxuICAgKiB0aGUgc2Vjb25kIGJlaW5nIHRodW1iIGluZGV4LlxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1sZW5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHppbGxvdy9yZWFjdC9yZXF1aXJlLWRlZmF1bHQtcHJvcHMsIHppbGxvdy9yZWFjdC9uby11bnVzZWQtcHJvcC10eXBlc1xuICBvbkNoYW5nZTogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGNhbGxlZCBvbmx5IGFmdGVyIG1vdmluZyBhIHRodW1iIGhhcyBlbmRlZC4gVGhlIGNhbGxiYWNrIHdpbGwgb25seSBiZSBjYWxsZWQgaWZcbiAgICogdGhlIGFjdGlvbiByZXN1bHRlZCBpbiBhIGNoYW5nZS4gVGhlIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHdpdGggdHdvIGFyZ3VtZW50cywgdGhlXG4gICAqIGZpcnN0IGJlaW5nIHRoZSByZXN1bHQgdmFsdWUocykgdGhlIHNlY29uZCBiZWluZyB0aHVtYiBpbmRleC5cbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtbGVuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB6aWxsb3cvcmVhY3QvcmVxdWlyZS1kZWZhdWx0LXByb3BzLCB6aWxsb3cvcmVhY3Qvbm8tdW51c2VkLXByb3AtdHlwZXNcbiAgb25BZnRlckNoYW5nZTogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGNhbGxlZCB3aGVuIHRoZSB0aGUgc2xpZGVyIGlzIGNsaWNrZWQgKHRodW1iIG9yIHRyYWNrcykuXG4gICAqIFJlY2VpdmVzIHRoZSB2YWx1ZSBhdCB0aGUgY2xpY2tlZCBwb3NpdGlvbiBhcyBhcmd1bWVudC5cbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB6aWxsb3cvcmVhY3QvcmVxdWlyZS1kZWZhdWx0LXByb3BzXG4gIG9uU2xpZGVyQ2xpY2s6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBhcmlhLWxhYmVsIGZvciBzY3JlZW4tcmVhZGVycyB0byBhcHBseSB0byB0aGUgdGh1bWJzLlxuICAgKiBVc2UgYW4gYXJyYXkgZm9yIG1vcmUgdGhhbiBvbmUgdGh1bWIuXG4gICAqIFRoZSBsZW5ndGggb2YgdGhlIGFycmF5IG11c3QgbWF0Y2ggdGhlIG51bWJlciBvZiB0aHVtYnMgaW4gdGhlIHZhbHVlIGFycmF5LlxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHppbGxvdy9yZWFjdC9yZXF1aXJlLWRlZmF1bHQtcHJvcHNcbiAgYXJpYUxhYmVsOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMuc3RyaW5nKV0pLFxuXG4gIC8qKlxuICAgKiBhcmlhLWxhYmVsbGVkYnkgZm9yIHNjcmVlbi1yZWFkZXJzIHRvIGFwcGx5IHRvIHRoZSB0aHVtYnMuXG4gICAqIFVzZWQgd2hlbiBzbGlkZXIgcmVuZGVyZWQgd2l0aCBzZXBhcmF0ZSBsYWJlbC5cbiAgICogVXNlIGFuIGFycmF5IGZvciBtb3JlIHRoYW4gb25lIHRodW1iLlxuICAgKiBUaGUgbGVuZ3RoIG9mIHRoZSBhcnJheSBtdXN0IG1hdGNoIHRoZSBudW1iZXIgb2YgdGh1bWJzIGluIHRoZSB2YWx1ZSBhcnJheS5cbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB6aWxsb3cvcmVhY3QvcmVxdWlyZS1kZWZhdWx0LXByb3BzXG4gIGFyaWFMYWJlbGxlZGJ5OiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMuc3RyaW5nKV0pLFxuXG4gIC8qKlxuICAgKiBhcmlhLXZhbHVldGV4dCBmb3Igc2NyZWVuLXJlYWRlcnMuXG4gICAqIENhbiBiZSBhIHN0YXRpYyBzdHJpbmcsIG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgc3RyaW5nLlxuICAgKiBUaGUgZnVuY3Rpb24gd2lsbCBiZSBwYXNzZWQgYSBzaW5nbGUgYXJndW1lbnQsXG4gICAqIGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICpcbiAgICogICAgIHN0YXRlID0+IGBWYWx1ZTogJHtzdGF0ZS52YWx1ZX1gXG4gICAqXG4gICAqIC0gYHN0YXRlLmluZGV4YCB7YG51bWJlcmB9IHRoZSBpbmRleCBvZiB0aGUgdGh1bWJcbiAgICogLSBgc3RhdGUudmFsdWVgIHtgbnVtYmVyYCB8IGBhcnJheWB9IHRoZSBjdXJyZW50IHZhbHVlIHN0YXRlXG4gICAqIC0gYHN0YXRlLnZhbHVlTm93YCB7YG51bWJlcmB9IHRoZSB2YWx1ZSBvZiB0aGUgdGh1bWIgKGkuZS4gYXJpYS12YWx1ZW5vdylcbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB6aWxsb3cvcmVhY3QvcmVxdWlyZS1kZWZhdWx0LXByb3BzXG4gIGFyaWFWYWx1ZXRleHQ6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5mdW5jXSksXG5cbiAgLyoqXG4gICAqIFByb3ZpZGUgYSBjdXN0b20gcmVuZGVyIGZ1bmN0aW9uIGZvciB0aGUgdHJhY2sgbm9kZS5cbiAgICogVGhlIHJlbmRlciBmdW5jdGlvbiB3aWxsIGJlIHBhc3NlZCB0d28gYXJndW1lbnRzLFxuICAgKiBhbiBvYmplY3Qgd2l0aCBwcm9wcyB0aGF0IHNob3VsZCBiZSBhZGRlZCB0byB5b3VyIGhhbmRsZSBub2RlLFxuICAgKiBhbmQgYW4gb2JqZWN0IHdpdGggdHJhY2sgYW5kIHNsaWRlciBzdGF0ZTpcbiAgICpcbiAgICogICAgIChwcm9wcywgc3RhdGUpID0+IDxkaXYgey4uLnByb3BzfSAvPlxuICAgKlxuICAgKiAtIGBwcm9wc2Age2BvYmplY3RgfSBwcm9wcyB0byBiZSBzcHJlYWQgaW50byB5b3VyIHRyYWNrIG5vZGVcbiAgICogLSBgc3RhdGUuaW5kZXhgIHtgbnVtYmVyYH0gdGhlIGluZGV4IG9mIHRoZSB0cmFja1xuICAgKiAtIGBzdGF0ZS52YWx1ZWAge2BudW1iZXJgIHwgYGFycmF5YH0gdGhlIGN1cnJlbnQgdmFsdWUgc3RhdGVcbiAgICovXG4gIHJlbmRlclRyYWNrOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogUHJvdmlkZSBhIGN1c3RvbSByZW5kZXIgZnVuY3Rpb24gZm9yIGR5bmFtaWMgdGh1bWIgY29udGVudC5cbiAgICogVGhlIHJlbmRlciBmdW5jdGlvbiB3aWxsIGJlIHBhc3NlZCB0d28gYXJndW1lbnRzLFxuICAgKiBhbiBvYmplY3Qgd2l0aCBwcm9wcyB0aGF0IHNob3VsZCBiZSBhZGRlZCB0byB5b3VyIHRodW1iIG5vZGUsXG4gICAqIGFuZCBhbiBvYmplY3Qgd2l0aCB0aHVtYiBhbmQgc2xpZGVyIHN0YXRlOlxuICAgKlxuICAgKiAgICAgKHByb3BzLCBzdGF0ZSkgPT4gPGRpdiB7Li4ucHJvcHN9IC8+XG4gICAqXG4gICAqIC0gYHByb3BzYCB7YG9iamVjdGB9IHByb3BzIHRvIGJlIHNwcmVhZCBpbnRvIHlvdXIgdGh1bWIgbm9kZVxuICAgKiAtIGBzdGF0ZS5pbmRleGAge2BudW1iZXJgfSB0aGUgaW5kZXggb2YgdGhlIHRodW1iXG4gICAqIC0gYHN0YXRlLnZhbHVlYCB7YG51bWJlcmAgfCBgYXJyYXlgfSB0aGUgY3VycmVudCB2YWx1ZSBzdGF0ZVxuICAgKiAtIGBzdGF0ZS52YWx1ZU5vd2Age2BudW1iZXJgfSB0aGUgdmFsdWUgb2YgdGhlIHRodW1iIChpLmUuIGFyaWEtdmFsdWVub3cpXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgemlsbG93L3JlYWN0L3JlcXVpcmUtZGVmYXVsdC1wcm9wc1xuICByZW5kZXJUaHVtYjogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIFByb3ZpZGUgYSBjdXN0b20gcmVuZGVyIGZ1bmN0aW9uIGZvciB0aGUgbWFyayBub2RlLlxuICAgKiBUaGUgcmVuZGVyIGZ1bmN0aW9uIHdpbGwgYmUgcGFzc2VkIG9uZSBhcmd1bWVudCxcbiAgICogYW4gb2JqZWN0IHdpdGggcHJvcHMgdGhhdCBzaG91bGQgYmUgYWRkZWQgdG8geW91ciBoYW5kbGUgbm9kZVxuICAgKlxuICAgKiAgICAgKHByb3BzKSA9PiA8c3BhbiB7Li4ucHJvcHN9IC8+XG4gICAqXG4gICAqIC0gYHByb3BzYCB7YG9iamVjdGB9IHByb3BzIHRvIGJlIHNwcmVhZCBpbnRvIHlvdXIgdHJhY2sgbm9kZVxuICAgKi9cbiAgcmVuZGVyTWFyazogUHJvcFR5cGVzLmZ1bmNcbn0gOiB7fTtcbnZhciBSZWFjdFNsaWRlciQxID0gUmVhY3RTbGlkZXI7XG5cbmV4cG9ydCB7IFJlYWN0U2xpZGVyJDEgYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UmVhY3RTbGlkZXIubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-slider/dist/es/dev/components/ReactSlider/ReactSlider.mjs\n");

/***/ })

};
;